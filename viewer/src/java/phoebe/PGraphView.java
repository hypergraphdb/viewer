package phoebe;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Paint;import java.awt.event.InputEvent;import java.beans.PropertyChangeSupport;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import javax.swing.JComponent;import javax.swing.SwingUtilities;import org.hypergraphdb.viewer.HGVComponent;import org.hypergraphdb.viewer.HGVNetwork;import org.hypergraphdb.viewer.util.PrimeFinder;import phoebe.event.BirdsEyeView;import phoebe.event.PContextMenu;import phoebe.event.PEdgeHandler;import phoebe.event.PEdgeSelectionHandler;import phoebe.event.PGraphEditEventHandler;import phoebe.event.PSelectionHandler;import phoebe.event.PToolTipHandler;import phoebe.event.SquiggleEventHandler;import phoebe.util.PrintingFixTextNode;import edu.umd.cs.piccolo.PCanvas;import edu.umd.cs.piccolo.PLayer;import edu.umd.cs.piccolo.PNode;import edu.umd.cs.piccolo.event.PInputEvent;import edu.umd.cs.piccolo.event.PInputEventFilter;import edu.umd.cs.piccolo.event.PZoomEventHandler;import edu.umd.cs.piccolo.util.PPaintContext;import edu.umd.cs.piccolox.swing.PScrollPane;import fing.model.FEdge;import fing.model.FNode;/** * <BR> * Default Behaviors:<BR> * <table cellpadding="2" cellspacing="2" border="1" style="text-align: left; * width: 100%;"> * <tr> * <td style="vertical-align: top;"> Middle-Click + Drag<br> * </td> * <td style="vertical-align: top;"> Move the entire canvas around the window<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;"> Right-Click + Drag<br> * </td> * <td style="vertical-align: top;"> Zoom in and Out<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;"> Left-Click + Drag<br> * </td> * <td style="vertical-align: top;"> Selection Marquee<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;"> CTRL+Left-Click on a FNode<br> * </td> * <td style="vertical-align: top;"> Start Making and FEdge, CTRL+Left-Click on * a different FNode to complete the edge.<br> * </td> * </tr> * </table> *  * <br> *  */public class PGraphView extends HeadlessGraphView {	public static int NODE_X_POSITION = 0;	public static int NODE_Y_POSITION = 1;	public static int NODE_SHAPE = 2;	public static int NODE_PAINT = 3;	public static int NODE_SELECTION_PAINT = 4;	public static int NODE_BORDER_PAINT = 5;	public static int NODE_BORDER_WIDTH = 6;	public static int NODE_WIDTH = 7;	public static int NODE_HEIGHT = 8;	public static int NODE_LABEL = 9;	public static int NODE_Z_POSITION = 10;	public static int SOURCE_INDEX = 0;	public static int TARGET_INDEX = 1;	public static int EDGE_WIDTH = 2;	public static int EDGE_LINE_TYPE = 3;	public static int EDGE_PAINT = 4;	public static int EDGE_SELECTION_PAINT = 5;	public static int EDGE_SOURCE_END_TYPE = 6;	public static int EDGE_SOURCE_END_PAINT = 7;	public static int EDGE_SOURCE_END_SELECTED_PAINT = 8;	public static int EDGE_TARGET_END_TYPE = 9;	public static int EDGE_TARGET_END_PAINT = 10;	public static int EDGE_TARGET_END_SELECTED_PAINT = 11;	public boolean updateEdges = true;	// init	protected boolean isInitialized = false;	// The Piccolo PCanvas that we will draw on	private PCanvas canvas;		protected Map<FNode, PNodeView> nodeViewMap;	protected Map<FEdge, PEdgeView> edgeViewMap;	// PCS support	protected PropertyChangeSupport pcs = new PropertyChangeSupport(this);	// A JPanel for the Canvas in the middle, and some other stuff around the	// sides	protected HGVComponent viewComponent;	// Piccolo Stuff for this class	protected PSelectionHandler selectionHandler;	protected PEdgeSelectionHandler edgeSelectionHandler;	protected PGraphEditEventHandler graphEditEventHandler;	protected PEdgeHandler edgeHandler;	protected PContextMenu contextMenu;	protected PToolTipHandler toolTipHandler;	protected SquiggleEventHandler squiggleEventHandler;	protected boolean edgeSelection = false;	protected boolean nodeSelection = false;	// layer	protected PLayer nodeLayer;	protected PLayer edgeLayer;	protected PLayer objectLayer;	protected PLayer squiggleLayer;	protected Color DEFAULT_BACKGROUND_COLOR = new java.awt.Color(60, 98, 176);	protected Object[] NODE_DEFAULTS;	protected Object[] EDGE_DEFAULTS;	protected HashMap<String, Object[]> contextMenuStore;	protected boolean noNodeSelection = true;	protected Map<FNode, Integer> nodeSelectionList;	protected boolean noEdgeSelection = true;	protected Map<FEdge, Integer> edgeSelectionList;	protected static boolean firePiccoloEvents = true;		// ----------------------------------------//	// Constructors and Initialization	// ----------------------------------------//	/**	 */	public PGraphView(String identifier, HGVNetwork net,			boolean setup) {		super(identifier, net);		initializePGraphView(setup);	}	public PGraphView(String identifier, HGVNetwork net) {		super(identifier, net);		initializePGraphView(true);	}	/**	 * Creates a new PGraphView given a HGVNetwork	 */	public PGraphView(HGVNetwork net) {		super(net);		initializePGraphView(true);	}	/**	 * Initialize this view by setting up the enclosing JComponent, setting up	 * the Piccolo-centric event handlers, and creating all of the viewable	 * objects from the model	 * 	 * @see createViewMatrix	 * @see initializeEventHandlers	 */	protected void initializePGraphView(boolean setup) {		// Set that we have initialized this View		isInitialized = true;		// Create the JPanel that we will put ourselves on.		// initialize the PCanvas and Enclosing Scroll Pane		// and add the whole shebang to the JPanel		viewComponent = new HGVComponent();		viewComponent.setLayout(new BorderLayout());		// AJK: 06/10/05 BEGIN		// substitute drop-enabled PhoebeCanvas		// canvas = new PCanvas() {		canvas = new PhoebeCanvas() {			// AJK: 06/10/05 END			// This avoids a bug which causes mouse motion events over the			// canvas to trigger repaint() calls. Mouse motion events			// mysteriously			// cause mouse exited events to be put on the AWT event queue, and			// in			// turn cause calls to repaint with a very small area at the origin			// of the canvas. We don't want to repaint the pixel at the origin			// of the canvas every time the mouse moves over the canvas.			// Repainting			// the origin pixel also causes other undesired side-effects, such			// as			// causing important repaint calls to actually repaint an area not			// only			// including the area to be repainted, but also including the			// origin.			// This causes a very large area to be repainted when this is			// inefficient.			public void repaint(long a, int x, int y, int w, int h) {				if (((x + w) > 1) || ((y + h) > 2))					super.repaint(a, x, y, w, h);			}		};		canvas				.setInteractingRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		canvas.setAnimatingRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		canvas.setDefaultRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		PScrollPane scroll = new PScrollPane(canvas);		viewComponent.add(scroll, BorderLayout.CENTER);		getCanvas().getCamera().setPaint(DEFAULT_BACKGROUND_COLOR);		System.out.println("Phoebe just built a canvas: " + canvas);		// Set up Layers		nodeLayer = new PLayer() {			public void addChild(int index, PNode child) {				PNode oldParent = child.getParent();				if (oldParent != null) {					oldParent.removeChild(child);				}				child.setParent(this);				getChildrenReference().add(index, child);				child.invalidatePaint();				invalidateFullBounds();				if (firePiccoloEvents)					firePropertyChange(0, PROPERTY_CHILDREN, null,							getChildrenReference());			}		};		edgeLayer = new PLayer() {			public void addChild(int index, PNode child) {				PNode oldParent = child.getParent();				if (oldParent != null) {					oldParent.removeChild(child);				}				child.setParent(this);				getChildrenReference().add(index, child);				child.invalidatePaint();				invalidateFullBounds();				if (firePiccoloEvents)					firePropertyChange(0, PROPERTY_CHILDREN, null,							getChildrenReference());			}		};		objectLayer = new PLayer();		squiggleLayer = new PLayer();		getCanvas().getLayer().addChild(edgeLayer);		getCanvas().getLayer().addChild(nodeLayer);		getCanvas().getLayer().addChild(objectLayer);		// Set up the the Piccolo Event Handlers		initializeEventHandlers();		// initialize all of the Viewable objects based on all of		// the Edges and Nodes currently in the network		nodeViewMap = new HashMap<FNode, PNodeView>(PrimeFinder				.nextPrime(network.getNodeCount()));		edgeViewMap = new HashMap<FEdge, PEdgeView>(PrimeFinder				.nextPrime(network.getEdgeCount()));		contextMenuStore = new HashMap<String, Object[]>(5);		// Just-In-Case you need some test nodes		// PNode a = PPath.createEllipse( 0, 0, 100, 100 );		// PNode b = PPath.createEllipse( 100, 100, 100, 100 );		// nodeLayer.addChild( a );		// nodeLayer.addChild( b );		NODE_DEFAULTS = new Object[] { new Double(DEFAULT_X),				new Double(DEFAULT_Y), new Integer(PNodeView.OCTAGON),				DEFAULT_NODE_PAINT, DEFAULT_NODE_SELECTION_PAINT,				DEFAULT_BORDER_PAINT, new Float(1), new Double(20),				new Double(20), "FNode" };		EDGE_DEFAULTS = new Object[] {				new Integer(0),				new Integer(0),				new Float(1),				// new int[] { PEdgeView.STRAIGHT_LINES },				new Integer(PEdgeView.STRAIGHT_LINES),				DEFAULT_EDGE_STROKE_PAINT, DEFAULT_EDGE_STROKE_PAINT_SELECTION,				new Integer(2), DEFAULT_EDGE_END_PAINT, DEFAULT_EDGE_END_PAINT,				new Integer(3), DEFAULT_EDGE_END_PAINT, DEFAULT_EDGE_END_PAINT };		// only create the node/edge view if requested		if (setup)			createViewableObjects();		ensureNodeSelectionCapacity();		ensureEdgeSelectionCapacity();	}	/**	 * 	 * This will provide the default feel for P-based apps.	 * 	 */	protected void initializeEventHandlers() {		// Add a FNode Selection Handler		selectionHandler = new PSelectionHandler(getCanvas().getLayer(),				getNodeLayer(), getCanvas().getCamera());		selectionHandler.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON1_MASK));		// enableNodeSelection();		// Add an FEdge Selection Handler		edgeSelectionHandler = new PEdgeSelectionHandler(				getCanvas().getLayer(), getEdgeLayer(), getCanvas().getCamera());		edgeSelectionHandler.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON1_MASK));		// enableEdgeSelection();		// Add a Edit Handler		graphEditEventHandler = new PGraphEditEventHandler(getCanvas(), this);		// getCanvas().addInputEventListener(graphEditEventHandler);		// Only allow panning via Middle Mouse button		getCanvas().getPanEventHandler().setEventFilter(				new PInputEventFilter(InputEvent.BUTTON2_MASK));		PZoomEventHandler zoomer = new PZoomEventHandler() {			public void dragActivityFinalStep(PInputEvent e) {				// System.out.println( "Scale: "+e.getCamera().getViewScale() );				if (e.getCamera().getViewScale() < .45) {					// getCanvas().setDefaultRenderQuality(PPaintContext.LOW_QUALITY_RENDERING);				} else {					// getCanvas().setDefaultRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);				}			}		};		zoomer.setMinScale(.05);		zoomer.setMaxScale(20);		zoomer.setEventFilter(new PInputEventFilter(InputEvent.BUTTON3_MASK));		getCanvas().setZoomEventHandler(zoomer);		// set the minumum zoom		// getCanvas().getZoomEventHandler().		// setMinScale( .1 );		// // add the zoom event handler		// getCanvas().getZoomEventHandler().		// setEventFilter(new PInputEventFilter(InputEvent.BUTTON3_MASK));		// add the FEdge Selection handler		edgeHandler = new PEdgeHandler(this);		getCanvas().addInputEventListener(edgeHandler);		// add the context menu handler		contextMenu = new PContextMenu(this);		contextMenu.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON3_MASK));		getCanvas().addInputEventListener(contextMenu);		// add the tool tip handler		toolTipHandler = new PToolTipHandler(getCanvas().getCamera());		getCanvas().getCamera().addInputEventListener(toolTipHandler);		// create the Squiggle handler		squiggleEventHandler = new SquiggleEventHandler(squiggleLayer,				getCanvas(), this);	}	public PEdgeHandler getEdgeHandler() {		return edgeHandler;	}	public void nodeSelected(PNodeView node) {		nodeSelectionList.put(node.getNode(), 1);		noNodeSelection = false;		network.getFlagger().setFlagged(node.getNode(), true);	}	public void nodeUnselected(PNodeView node) {		nodeSelectionList.put(node.getNode(), 0);		noNodeSelection = false;		network.getFlagger().setFlagged(node.getNode(), false);	}	public void edgeSelected(PEdgeView edge) {		edgeSelectionList.put(edge.getEdge(), 1);		noEdgeSelection = false;		network.getFlagger().setFlagged(edge.getEdge(), true);	}	public void edgeUnselected(PEdgeView edge) {		edgeSelectionList.put(edge.getEdge(), 0);		network.getFlagger().setFlagged(edge.getEdge(), true);	}	protected void clearNodeSelectionList() {		nodeSelectionList = new HashMap<FNode, Integer>(getNetwork()				.getNodeCount());	}	protected void ensureNodeSelectionCapacity() {		if (nodeSelectionList == null) {			nodeSelectionList = new HashMap<FNode, Integer>(					getNetwork().getNodeCount());		}	}	protected void clearEdgeSelectionList() {		edgeSelectionList = new HashMap<FEdge, Integer>(getNetwork()				.getEdgeCount());	}	protected void ensureEdgeSelectionCapacity() {		if (edgeSelectionList == null) {			edgeSelectionList = new HashMap<FEdge, Integer>(					getNetwork().getEdgeCount());		}	}	/**	 * 	 * @return a list of the selected PNodeView	 * 	 */	public List<PNodeView> getSelectedNodes() {		ArrayList<PNodeView> selected = new ArrayList<PNodeView>(				nodeSelectionList.size());		for (Iterator<FNode> it = getNetwork().nodesIterator(); it				.hasNext();) {			FNode n = it.next();			if (nodeSelectionList.containsKey(n)					&& nodeSelectionList.get(n) == 1)				selected.add(getNodeView(n));		}		return selected;	}	/**	 * 	 * @return a list of the selected PEdgeView	 * 	 */	public List<PEdgeView> getSelectedEdges() {		ArrayList<PEdgeView> selected = new ArrayList<PEdgeView>(				edgeSelectionList.size());		for (Iterator<FEdge> it = getNetwork().edgesIterator(); it				.hasNext();) {			FEdge idx = it.next();			if (edgeSelectionList.containsKey(idx)					&& edgeSelectionList.get(idx) == 1)				selected.add(getEdgeView(idx));		}		return selected;	}	public void prepareToPrint() {		getCanvas().getCamera().addClientProperty(				PrintingFixTextNode.PRINTING_CLIENT_PROPERTY_KEY, "true");	}	public void donePrinting() {		getCanvas().getCamera().addClientProperty(				PrintingFixTextNode.PRINTING_CLIENT_PROPERTY_KEY, null);	}	public double getWidth() {		return getCanvas().getWidth();	}	public double getHeight() {		return getCanvas().getHeight();	}	/**	 * @param the new Paint for the background	 */	public void setBackgroundPaint(Paint paint) {		getCanvas().getCamera().setPaint(paint);	}	/**	 * 	 * @return the backgroundPaint	 * 	 */	public Paint getBackgroundPaint() {		return getCanvas().getCamera().getPaint();	}	// ----------------------------------------//	// Event Handlers	// ----------------------------------------//	public boolean nodeSelectionEnabled() {		return nodeSelection;	}	public boolean edgeSelectionEnabled() {		return edgeSelection;	}	public void enableNodeSelection() {		if (!nodeSelection) {			getCanvas().addInputEventListener(getSelectionHandler());		}		nodeSelection = true;	}	public void disableNodeSelection() {		if (nodeSelection) {			getCanvas().removeInputEventListener(getSelectionHandler());		}		nodeSelection = false;	}	/**	 * 	 * @return The Selection Handler	 * 	 */	public PSelectionHandler getSelectionHandler() {		return selectionHandler;	}	public void enableEdgeSelection() {		if (!edgeSelection) {			getCanvas().addInputEventListener(getEdgeSelectionHandler());		}		edgeSelection = true;	}	public void disableEdgeSelection() {		if (edgeSelection) {			getCanvas().removeInputEventListener(getEdgeSelectionHandler());		}		edgeSelection = false;	}	public PEdgeSelectionHandler getEdgeSelectionHandler() {		return edgeSelectionHandler;	}	public void enablePanning() {		getCanvas().addInputEventListener(getCanvas().getPanEventHandler());	}	public void disablePanning() {		getCanvas().removeInputEventListener(getCanvas().getPanEventHandler());	}	/**	 * 	 * @return the Squiggle Event Handler	 * 	 */	public SquiggleEventHandler getSquiggleHandler() {		return squiggleEventHandler;	}	public void openNodeEditor(PNodeView nv) {		// if ( nodeEditor == null ) {		// nodeEditor = new PNodeViewEditor( this );		// }		// nodeEditor.setCurrentNode( nv );		// nodeEditor.setVisible( true );	}	/**	 * 	 * This BirdsEyeView only looks at the nodes.	 * 	 * @return The BirdsEyeView that needs to be put into a frame/dialog/pane	 * 	 */	public JComponent getBirdsEyeView() {		BirdsEyeView canvas = new BirdsEyeView();		canvas.connect(getCanvas(), new PLayer[] { getCanvas().getLayer() });		return canvas;	}	/**	 * 	 * @return HGVComponent that can be added to most screen things	 * 	 */	public HGVComponent getComponent() {		return viewComponent;	}	/**	 * @return The Piccolo PCanvas that the Graph is Drawn on	 */	public PCanvas getCanvas() {		return canvas;	}	/**	 * @return The PLayer that all Nodes are added to	 */	public PLayer getNodeLayer() {		return nodeLayer;	}	/**	 * @return The PLayer that all Edges are added to	 */	public PLayer getEdgeLayer() {		return edgeLayer;	}	/**	 * @return The PLayer that all non-FNode and non-FEdge objects can be added	 *         to	 */	public PLayer getObjectLayer() {		return objectLayer;	}	/**	 * @param node Access to adding a FNode to the Graph	 */	public void addToNodeLayer(PNode node) {		nodeLayer.addChild(node);	}	/**	 * 	 * @param edge	 *            Access to adding an FEdge to the Graph	 * 	 */	public void addToEdgeLayer(PNode edge) {		edgeLayer.addChild(edge);	}	/**	 * This method will create a Viewable PNode derivative for every node and	 * FEdge in the network	 */	protected void createViewableObjects() {		firePiccoloEvents = false;		long time = System.currentTimeMillis();		PNodeView node_view;		ArrayList<PNodeView> node_view_list = new ArrayList<PNodeView>(				network.getNodeCount());		for (Iterator<FNode> it = network.nodesIterator(); it.hasNext();) {			// System.out.println( "Creating a PNodeView for: "+ index + "			// mapped to: "+node_indices[index] );			// Add Nodes in a Default Layout			// TODO: Remove?			if (DEFAULT_X % 2000 == 0) {				DEFAULT_Y += 100;				DEFAULT_X = 100;			} else {				DEFAULT_X += 100;			}			// Only need to Change the X and Y			NODE_DEFAULTS[0] = new Double(DEFAULT_X);			NODE_DEFAULTS[1] = new Double(DEFAULT_Y);			FNode node = it.next();			setAllNodePropertyData(node, (Object[]) NODE_DEFAULTS.clone());			node_view = new PNodeView(node, this);			// System.out.println( "Putting NOde: "+node_indices[index] );			nodeViewMap.put(node, node_view);			node_view_list.add(node_view);			addToNodeLayer(node_view);		}		System.out.println("Create Nodes took: "				+ (System.currentTimeMillis() - time));		// add all nodes to the layer at once		// nodeLayer.addChildren( node_view_list );		// new, faster? implementation....		PEdgeView edge_view;		ArrayList<PEdgeView> edge_view_list = new ArrayList<PEdgeView>();		for (Iterator<FEdge> it = network.edgesIterator(); it.hasNext();) {			FEdge edge = it.next();			// TODO:???			EDGE_DEFAULTS[0] = edge.getSource();			EDGE_DEFAULTS[1] = edge.getTarget();			setAllEdgePropertyData(edge, (Object[]) EDGE_DEFAULTS.clone());			edge_view = new PEdgeView(edge, this);			addToEdgeLayer(edge_view);			edge_view_list.add(edge_view);			edgeViewMap.put(edge, edge_view);		}		// edgeLayer.addChildren( edge_view_list );		firePiccoloEvents = true;		System.out.println("Create Viewable Object took: "				+ (System.currentTimeMillis() - time));	}	/**	 * @param node_index	 *            the index of a node to have a view created for it	 * @return a new PNodeView based on the node with the given index	 */	public PNodeView addNodeView(FNode node_index) {		ensureNodeSelectionCapacity();		if (DEFAULT_X % 2000 == 0) {			DEFAULT_Y += 100;			DEFAULT_X = 100;		} else {			DEFAULT_X += 100;		}		// Only need to Change the X and Y		NODE_DEFAULTS[0] = new Double(DEFAULT_X);		NODE_DEFAULTS[1] = new Double(DEFAULT_Y);		setAllNodePropertyData(node_index, (Object[]) NODE_DEFAULTS.clone());		PNodeView node_view = new PNodeView(node_index, this);		nodeViewMap.put(node_index, node_view);		addToNodeLayer(node_view);		return node_view;	}	public PEdgeView addEdgeView(FEdge edge) {		ensureEdgeSelectionCapacity();		EDGE_DEFAULTS[0] = edge.getSource();		EDGE_DEFAULTS[1] = edge.getTarget();		 setAllEdgePropertyData(edge, (Object[]) EDGE_DEFAULTS.clone());		PEdgeView edge_view = new PEdgeView(edge, this);		addToEdgeLayer(edge_view);		// getCanvas().getLayer().addChild( edge_view );		edgeViewMap.put(edge, edge_view);		return edge_view;	}	/**	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This	 * is different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 *                       This method will destroy the object. It will be	 *                       returned though, so that a reference can be kept	 *                       for undo purposes.	 */	public PNodeView removeNodeView(PNodeView node_view) {		try {			node_view.removeFromParent();		} catch (Exception e) {			// System.out.println( "Parent was most likeley null for: "+			// node_view );			return null;		}		nodeViewMap.remove(node_view.getNode());		ensureNodeSelectionCapacity();		nodeSelectionList.put(node_view.getNode(), 0);		return node_view;	}	/**	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This	 * is different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 *                       This method will destroy the object. It will be	 *                       returned though, so that a reference can be kept	 *                       for undo purposes.	 */	public PNodeView removeNodeView(FNode node) {		PNodeView node_view = (PNodeView) getNodeView(node);		try {			node_view.removeFromParent();		} catch (Exception e) {			// System.out.println( "Parent was most likeley null for: "+ node);			return null;		}		nodeViewMap.remove(node_view.getNode());		ensureNodeSelectionCapacity();		nodeSelectionList.put(node_view.getNode(), 0);		return node_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This	 * is different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 *                       This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PEdgeView removeEdgeView(PEdgeView edge_view) {		try {			((PNode) edge_view).removeFromParent();		} catch (Exception e) {			// System.out.println( "Parent was most likeley null for: " +			// edge_view );			return null;		}		edgeViewMap.remove(edge_view);		ensureEdgeSelectionCapacity();		edgeSelectionList.put(edge_view.getEdge(), 0);		return edge_view;	}	/**	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This	 * is different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 *                       This method will destroy the object. It will be	 *                       returned though, so that a reference can be kept	 *                       for undo purposes.	 */	public PEdgeView removeEdgeView(FEdge edge) {		PEdgeView edge_view = (PEdgeView) getEdgeView(edge);		try {			edge_view.removeFromParent();		} catch (Exception e) {			// System.out.println( "Parent was most likely null for: " + edge );			return null;		}		edgeViewMap.remove(edge_view);		ensureEdgeSelectionCapacity();		edgeSelectionList.put(edge_view.getEdge(), 0);		return edge_view;	}	/**	 * 	 * @return The Unique Identifier of this GraphView	 * 	 */	public String getIdentifier() {		return identifier;	} // getIdentifier()	/**	 * 	 * @param new_identifier	 *            The New Identifier for this GraphView	 * 	 */	public void setIdentifier(String new_identifier) {		if (identifier == null) {			if (new_identifier == null) {				return;			}		} else if (new_identifier != null) {			if (identifier.equals(new_identifier)) {				return;			}		}		String old_identifier = identifier;		identifier = new_identifier;		pcs.firePropertyChange("identifier", old_identifier, new_identifier);	} // setIdentifier(..)	/**	 * 	 * @return The Current Zoom Level	 * 	 */	public double getZoom() {		return getCanvas().getCamera().getViewScale();	}	/**	 * 	 * @param d	 *            The New ZoomLevel	 * 	 */	public void setZoom(double d) {		// PBounds bounds = getCanvas().getCamera().getViewBounds();		// double x = bounds.getX();		// double y = bounds.getY();		// double h = bounds.getHeight();		// double w = bounds.getWidth();		java.awt.geom.Point2D point = getCanvas().getCamera().getBounds()				.getCenter2D();		point = getCanvas().getCamera().localToView(point);		getCanvas().getCamera().scaleViewAboutPoint(d, point.getX(),				point.getY());		// getCanvas().getCamera() .scaleViewAboutPoint( d, x + ( w - x ) /2 , y		// + ( h -y ) /2 );		// System.out.println( "X: "+x+" Y: "+y+" H: "+h+" W: "+w );		// PNode node = new PNode();		// node.setPaint( Color.red );		// getCanvas().getLayer().addChild( node );		// node.setOffset( x + ( w - x ) /2 , y + ( h -y ) /2 );	}	/**	 * 	 * Fits all Viewable elements onto the Graph	 * 	 */	public void fitContent() {		SwingUtilities.invokeLater(new Runnable() {			public void run() {				getCanvas().getCamera().animateViewToCenterBounds(						getCanvas().getLayer().getFullBounds(), true, 500l);				if (getCanvas().getCamera().getViewScale() < .45) {					// getCanvas().setDefaultRenderQuality(PPaintContext.LOW_QUALITY_RENDERING);				}			}		});		// System.out.println( "Fitting Content: "+		// getCanvas().getLayer().getFullBounds() );		// try {		// PTransformActivity activity =		// getCanvas().getCamera().animateViewToCenterBounds(		// getCanvas().getLayer().getGlobalFullBounds(), true, 500l );		// getCanvas().getCamera().addActivity( activity );		// } catch ( Exception e ) {		// oh yes, this is hacky.		// }	}	/**	 * 	 * Do a global redraw of the entire canvas	 * 	 */	public void updateView() {		// getCanvas().getCamera().repaint();	}	/**	 * nodeViewsList only returns the NodeViews that are explicitly associated	 * with this GraphView	 */	public List<PNodeView> getNodeViewsList() {		ArrayList<PNodeView> list = new ArrayList<PNodeView>(getNodeViewCount());		for (FNode i : nodeViewMap.keySet())			list.add(nodeViewMap.get(i));		return list;	}	/**	 * nodeViewsIterator only returns the NodeViews that are explicitly	 * associated with this GraphView	 * 	 */	public Iterator<PNodeView> getNodeViewsIterator() {		return getNodeViewsList().iterator();	}	/**	 * 	 */	public int getNodeViewCount() {		return nodeViewMap.size();	}	/**	 * 	 */	public int getEdgeViewCount() {		return edgeViewMap.size();	}	/**	 * @param node	 *            The FNode whose view is requested	 * @return The PNodeView of the given FNode	 * 	 */	public PNodeView getNodeView(FNode node) {		return nodeViewMap.get(node);	}	public List<PEdgeView> getEdgeViewsList() {		ArrayList<PEdgeView> list = new ArrayList<PEdgeView>(getEdgeViewCount());		for (FEdge i : edgeViewMap.keySet())			list.add(edgeViewMap.get(i));		return list;	}	/**	 * Return all of the EdgeViews in this GraphView	 */	public Iterator<PEdgeView> getEdgeViewsIterator() {		return getEdgeViewsList().iterator();	}	// implements GraphView	public PEdgeView getEdgeView(FEdge edge) {		return edgeViewMap.get(edge);	}	/**	 * Hides an Object that is in the Graph by removing it from the Piccolo	 * Scene Graph <B>Note:</B> The object must inherit from	 * 	 * @see PNode	 * @see PGraphView#hideNodeView( PNodeView )	 * @see PGraphView#hideNodeView( PNodeView, boolean )	 */	public boolean hideGraphObject(Object object) {		try {			((PNode) object).removeFromParent();		} catch (Exception e) {			// System.out.println( "Parent was most likeley null for: "+object			// );			return false;		}		return true;	}	/**	 * 	 * Shows an Object that is in the Graph by addng it to the	 * 	 * Piccolo Scene Graph	 * 	 * <B>Note:</B> The object must inherit from	 * 	 * @see PNode	 * 	 */	public boolean showGraphObject(Object object) {		if (object == null) {			// System.out.println( "Object was Null" );			return false;		}		PNode obj = (PNode) object;		// System.out.println( "Showing: "+object );		try {			if (obj.getParent() != null) {				// System.out.println( "Object parent for: "+obj+" was not				// null." );				return false;			}		} catch (Exception e) {			// System.out.println( "Parent was most likeley null for: "+object			// );			return false;		}		if (object instanceof PNodeView) {			// its a node, should be on the node layer			nodeLayer.addChild((PNode) object);			return true;		} else if (object instanceof PEdgeView) {			// its an edge			edgeLayer.addChild((PNode) object);			return true;		} else {			return false;		}	}	/**	 * 	 * Hides a group of GraphObjects	 * 	 */	public boolean hideGraphObjects(List objects) {		Iterator pnodes = objects.iterator();		while (pnodes.hasNext()) {			hideGraphObject((PNode) pnodes.next());		}		return true;	}	// ----------------------------------------//	// Context Menu Stuff	public Object[] getContextMethods(String class_name, boolean plus_superclass) {		if (class_name.startsWith("class ")) {			class_name = class_name.substring(6, class_name.length());		}		if (plus_superclass) {			try {				return getContextMethods(class_name, null);			} catch (Exception ex) {				System.out.println("Exception encounterd getting methods");				ex.printStackTrace();				return null;			}		}		return contextMenuStore.get(class_name);	}	public Object[] getContextMethods(String class_name, Object[] methods) {		if (class_name.startsWith("class ")) {			class_name = class_name.substring(6, class_name.length());		}		try {			Class c = Class.forName(class_name);			if (methods == null) {				methods = contextMenuStore.get(class_name);			} else {				Object[] new_methods = contextMenuStore.get(class_name);				if (new_methods != null) {					// we need to tack onto methods					Object[] return_methods = new Object[new_methods.length							+ methods.length];					System.arraycopy(methods, 0, return_methods, 0,							methods.length);					System.arraycopy(new_methods, 0, return_methods,							methods.length, new_methods.length);					methods = return_methods;				}			}			// Class[] interfaces = c.getInterfaces();			// for ( int i = 0; i < interfaces.length; ++i ) {			// methods = getContextMethods( interfaces[i].getName(), methods );			// }			Class sc = c.getSuperclass();			if (!sc.getName().equals("java.lang.Object")) {				return getContextMethods(sc.getName(), methods);			} else {				return methods;			}		} catch (Exception exc) {			exc.printStackTrace();			return methods;		}	}	/**	 * 	 * @param class_name	 *            This is the class that should get this method in its	 *            ContextMenu	 * 	 * @param method_class_name	 *            the name of the class that contains the method	 * 	 * @param method_name	 *            the name of the method	 * 	 * @param args	 *            every method will take both an Object[] of whatever, and a	 *            PNode	 * 	 */	public boolean addContextMethod(String class_name,			String method_class_name, String method_name, Object[] args,			ClassLoader loader) {		if (class_name.startsWith("class ")) {			class_name = class_name.substring(6, class_name.length());		}		Object old_store = (Object) contextMenuStore.get(class_name);		Object[] new_store;		if (old_store == null) {			// no methods previously existed for this type of class			new_store = new Object[] { new Object[] { method_class_name,					method_name, args, loader } };		} else {			Object[] store = (Object[]) old_store;			new_store = new Object[store.length + 1];			System.arraycopy(store, 0, new_store, 0, store.length);			new_store[store.length] = new Object[] { method_class_name,					method_name, args, loader };		}		contextMenuStore.put(class_name, new_store);		return true;	}} // class PGraphView