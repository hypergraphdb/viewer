package phoebe;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Component;import java.awt.Paint;import java.awt.event.InputEvent;import java.beans.PropertyChangeSupport;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import javax.swing.JComponent;import javax.swing.JPanel;import javax.swing.SwingUtilities;import javax.swing.event.EventListenerList;import org.hypergraphdb.viewer.util.PrimeFinder;import phoebe.event.BirdsEyeView;import phoebe.event.GraphViewChangeEvent;import phoebe.event.GraphViewChangeListener;import phoebe.event.PContextMenu;import phoebe.event.PEdgeHandler;import phoebe.event.PEdgeSelectionHandler;import phoebe.event.PGraphEditEventHandler;import phoebe.event.PSelectionHandler;import phoebe.event.PToolTipHandler;import phoebe.event.SquiggleEventHandler;import phoebe.util.PrintingFixTextNode;import edu.umd.cs.piccolo.PCanvas;import edu.umd.cs.piccolo.PLayer;import edu.umd.cs.piccolo.PNode;import edu.umd.cs.piccolo.event.PInputEvent;import edu.umd.cs.piccolo.event.PInputEventFilter;import edu.umd.cs.piccolo.event.PZoomEventHandler;import edu.umd.cs.piccolo.util.PPaintContext;import edu.umd.cs.piccolox.swing.PScrollPane;import fing.model.FEdge;import fing.model.FGraphPerspective;import fing.model.FNode;import fing.model.FRootGraph;/** * <BR> * Default Behaviors:<BR> * <table cellpadding="2" cellspacing="2" border="1" style="text-align: left; * width: 100%;"> * <tr> * <td style="vertical-align: top;"> * Middle-Click + Drag<br> * </td> * <td style="vertical-align: top;"> * Move the entire canvas around the window<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;"> * Right-Click + Drag<br> * </td> * <td style="vertical-align: top;"> * Zoom in and Out<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;">  * Left-Click + Drag<br> * </td> * <td style="vertical-align: top;"> * Selection Marquee<br> * </td> * </tr> * <tr> * <td style="vertical-align: top;"> * CTRL+Left-Click on a FNode<br> * </td> * <td style="vertical-align: top;"> * Start Making and FEdge, CTRL+Left-Click on a different FNode to complete the * edge.<br>* </td> * </tr> * </table> *  * <br> *  */public class PGraphView extends HeadlessGraphView //implements GraphView{	public static int NODE_X_POSITION = 0;	  public static int NODE_Y_POSITION = 1;	  public static int NODE_SHAPE = 2;	  public static int NODE_PAINT = 3;	  public static int NODE_SELECTION_PAINT = 4;	  public static int NODE_BORDER_PAINT = 5;	  public static int NODE_BORDER_WIDTH = 6;	  public static int NODE_WIDTH = 7;	  public static int NODE_HEIGHT = 8;	  public static int NODE_LABEL = 9;	  public static int NODE_Z_POSITION = 10;	  public static int SOURCE_INDEX = 0;	  public static int TARGET_INDEX = 1;	  public static int EDGE_WIDTH = 2;	  public static int EDGE_LINE_TYPE = 3;	  public static int EDGE_PAINT = 4;	  public static int EDGE_SELECTION_PAINT = 5;	  public static int EDGE_SOURCE_END_TYPE = 6;	  public static int EDGE_SOURCE_END_PAINT = 7;	  public static int EDGE_SOURCE_END_SELECTED_PAINT = 8;	  public static int EDGE_TARGET_END_TYPE = 9;	  public static int EDGE_TARGET_END_PAINT = 10;	  public static int EDGE_TARGET_END_SELECTED_PAINT = 11;	public boolean updateEdges = true; 	// init	protected boolean isInitialized = false;	// The Piccolo PCanvas that we will draw on	private PCanvas canvas;	/**	 * 	 * Stores a map from the RootGraph index to the viewable object	 * 	 */	protected Map<Integer, PNodeView> nodeViewMap;	/**	 * 	 * Stores a map from the RootGraph index to the viewable object	 * 	 */	protected Map<Integer, PEdgeView> edgeViewMap;	// PCS support	protected PropertyChangeSupport pcs = new PropertyChangeSupport(this);	// A JPanel for the Canvas in the middle, and some other stuff around the	// sides	protected JPanel viewComponent;	// Piccolo Stuff for this class	protected PSelectionHandler selectionHandler;	protected PEdgeSelectionHandler edgeSelectionHandler;	protected PGraphEditEventHandler graphEditEventHandler;	protected PEdgeHandler edgeHandler;	protected PContextMenu contextMenu;	protected PToolTipHandler toolTipHandler;	protected SquiggleEventHandler squiggleEventHandler;	protected boolean edgeSelection = false;	protected boolean nodeSelection = false;	// layer	protected PLayer nodeLayer;	protected PLayer edgeLayer;	protected PLayer objectLayer;	protected PLayer squiggleLayer;	protected Color DEFAULT_BACKGROUND_COLOR = new java.awt.Color(60, 98, 176);	protected Object[] NODE_DEFAULTS;	protected Object[] EDGE_DEFAULTS;	protected HashMap contextMenuStore;	protected boolean noNodeSelection = true;	protected Map<Integer, Integer> nodeSelectionList;	protected boolean noEdgeSelection = true;	protected Map<Integer, Integer> edgeSelectionList;	/**	 * 	 * The event that we fire when this ColtRootGraph changes.	 * 	 */	// TODO: When we multithread this we'll want one per thread	protected ChangeEvent phoebeGraphViewChangeEvent;	protected static boolean firePiccoloEvents = true;	/**	 * 	 * All event listeners are stored here.	 * 	 */	EventListenerList listenerList = new EventListenerList();	// ----------------------------------------//	// Constructors and Initialization	// ----------------------------------------//	/**	 * 	 * Create a new PGraphView, and set up default nodes and edges	 * 	 */	public PGraphView(String identifier, FGraphPerspective perspective,			boolean setup)	{		super(identifier, perspective);		initializePGraphView(setup);	}	/**	 * 	 * Create a new PGraphView by passing in an identifier and the perspective	 * to	 * 	 * which it is bound	 * 	 */	public PGraphView(String identifier, FGraphPerspective perspective)	{		super(identifier, perspective);		initializePGraphView(true);	}	/**	 * 	 * Creates a new PGraphView given a GraphPerspective and gets assigned a	 * 	 * default name	 * 	 */	public PGraphView(FGraphPerspective perspective)	{		super(perspective);		initializePGraphView(true);	}	/**	 * 	 * Initialize this view by setting up the enclosing JComponent, setting up	 * 	 * the Piccolo-centric event handlers, and creating all of the viewable	 * 	 * objects from the model	 * 	 * 	 * 	 * @see createViewMatrix	 * 	 * @see initializeEventHandlers	 * 	 */	protected void initializePGraphView(boolean setup)	{		// Set that we have initialized this View		isInitialized = true;		// Create the JPanel that we will put ourselves on.		// initialize the PCanvas and Enclosing Scroll Pane		// and add the whole shebang to the JPanel		viewComponent = new JPanel();		viewComponent.setLayout(new BorderLayout());		// AJK: 06/10/05 BEGIN		// substitute drop-enabled PhoebeCanvas		// canvas = new PCanvas() {		canvas = new PhoebeCanvas() {			// AJK: 06/10/05 END			// This avoids a bug which causes mouse motion events over the			// canvas to trigger repaint() calls. Mouse motion events			// mysteriously			// cause mouse exited events to be put on the AWT event queue, and			// in			// turn cause calls to repaint with a very small area at the origin			// of the canvas. We don't want to repaint the pixel at the origin			// of the canvas every time the mouse moves over the canvas.			// Repainting			// the origin pixel also causes other undesired side-effects, such			// as			// causing important repaint calls to actually repaint an area not			// only			// including the area to be repainted, but also including the			// origin.			// This causes a very large area to be repainted when this is			// inefficient.			public void repaint(long a, int x, int y, int w, int h)			{				if (((x + w) > 1) || ((y + h) > 2))					super.repaint(a, x, y, w, h);			}		};		canvas				.setInteractingRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		canvas.setAnimatingRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		canvas.setDefaultRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);		PScrollPane scroll = new PScrollPane(canvas);		viewComponent.add(scroll, BorderLayout.CENTER);		getCanvas().getCamera().setPaint(DEFAULT_BACKGROUND_COLOR);		System.out.println("Phoebe just built a canvas: " + canvas);		// Set up Layers		nodeLayer = new PLayer() {			public void addChild(int index, PNode child)			{				PNode oldParent = child.getParent();				if (oldParent != null)				{					oldParent.removeChild(child);				}				child.setParent(this);				getChildrenReference().add(index, child);				child.invalidatePaint();				invalidateFullBounds();				if (firePiccoloEvents)					firePropertyChange(0, PROPERTY_CHILDREN, null,							getChildrenReference());			}		};		edgeLayer = new PLayer() {			public void addChild(int index, PNode child)			{				PNode oldParent = child.getParent();				if (oldParent != null)				{					oldParent.removeChild(child);				}				child.setParent(this);				getChildrenReference().add(index, child);				child.invalidatePaint();				invalidateFullBounds();				if (firePiccoloEvents)					firePropertyChange(0, PROPERTY_CHILDREN, null,							getChildrenReference());			}		};		objectLayer = new PLayer();		squiggleLayer = new PLayer();		getCanvas().getLayer().addChild(edgeLayer);		getCanvas().getLayer().addChild(nodeLayer);		getCanvas().getLayer().addChild(objectLayer);		// Set up the the Piccolo Event Handlers		initializeEventHandlers();		// initialize all of the Viewable objects based on all of		// the Edges and Nodes currently in the GraphPerspective		nodeViewMap = new HashMap<Integer, PNodeView>(PrimeFinder				.nextPrime(perspective.getNodeCount()));		edgeViewMap = new HashMap<Integer, PEdgeView>(PrimeFinder				.nextPrime(perspective.getEdgeCount()));		contextMenuStore = new HashMap(5);		// Just-In-Case you need some test nodes		// PNode a = PPath.createEllipse( 0, 0, 100, 100 );		// PNode b = PPath.createEllipse( 100, 100, 100, 100 );		// nodeLayer.addChild( a );		// nodeLayer.addChild( b );		NODE_DEFAULTS = new Object[] { new Double(DEFAULT_X),				new Double(DEFAULT_Y), new Integer(PNodeView.OCTAGON),				DEFAULT_NODE_PAINT, DEFAULT_NODE_SELECTION_PAINT,				DEFAULT_BORDER_PAINT, new Float(1), new Double(20),				new Double(20), "FNode" };		EDGE_DEFAULTS = new Object[] {				new Integer(0),				new Integer(0),				new Float(1),				// new int[] { PEdgeView.STRAIGHT_LINES },				new Integer(PEdgeView.STRAIGHT_LINES),				DEFAULT_EDGE_STROKE_PAINT, DEFAULT_EDGE_STROKE_PAINT_SELECTION,				new Integer(2), DEFAULT_EDGE_END_PAINT, DEFAULT_EDGE_END_PAINT,				new Integer(3), DEFAULT_EDGE_END_PAINT, DEFAULT_EDGE_END_PAINT };		// only create the node/edge view if requested		if (setup) createViewableObjects();		ensureNodeSelectionCapacity();		ensureEdgeSelectionCapacity();	}	/**	 * 	 * This will provide the default feel for P-based apps.	 * 	 */	protected void initializeEventHandlers()	{		// Add a FNode Selection Handler		selectionHandler = new PSelectionHandler(getCanvas().getLayer(),				getNodeLayer(), getCanvas().getCamera());		selectionHandler.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON1_MASK));		// enableNodeSelection();		// Add an FEdge Selection Handler		edgeSelectionHandler = new PEdgeSelectionHandler(				getCanvas().getLayer(), getEdgeLayer(), getCanvas().getCamera());		edgeSelectionHandler.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON1_MASK));		// enableEdgeSelection();		// Add a Edit Handler		graphEditEventHandler = new PGraphEditEventHandler(getCanvas(), this);		// getCanvas().addInputEventListener(graphEditEventHandler);		// Only allow panning via Middle Mouse button		getCanvas().getPanEventHandler().setEventFilter(				new PInputEventFilter(InputEvent.BUTTON2_MASK));		PZoomEventHandler zoomer = new PZoomEventHandler() {			public void dragActivityFinalStep(PInputEvent e)			{				// System.out.println( "Scale: "+e.getCamera().getViewScale() );				if (e.getCamera().getViewScale() < .45)				{					// getCanvas().setDefaultRenderQuality(PPaintContext.LOW_QUALITY_RENDERING);				} else				{					// getCanvas().setDefaultRenderQuality(PPaintContext.HIGH_QUALITY_RENDERING);				}			}		};		zoomer.setMinScale(.05);		zoomer.setMaxScale(20);		zoomer.setEventFilter(new PInputEventFilter(InputEvent.BUTTON3_MASK));		getCanvas().setZoomEventHandler(zoomer);		// set the minumum zoom		// getCanvas().getZoomEventHandler().		// setMinScale( .1 );		// // add the zoom event handler		// getCanvas().getZoomEventHandler().		// setEventFilter(new PInputEventFilter(InputEvent.BUTTON3_MASK));		// add the FEdge Selection handler		edgeHandler = new PEdgeHandler(this);		getCanvas().addInputEventListener(edgeHandler);		// add the context menu handler		contextMenu = new PContextMenu(this);		contextMenu.setEventFilter(new PInputEventFilter(				InputEvent.BUTTON3_MASK));		getCanvas().addInputEventListener(contextMenu);		// add the tool tip handler		toolTipHandler = new PToolTipHandler(getCanvas().getCamera());		getCanvas().getCamera().addInputEventListener(toolTipHandler);		// create the Squiggle handler		squiggleEventHandler = new SquiggleEventHandler(squiggleLayer,				getCanvas(), this);	}	public PEdgeHandler getEdgeHandler()	{		return edgeHandler;	}	public void nodeSelected(PNodeView node)	{		// System.out.println( "FNode Selected. Root:		// "+node.getRootGraphIndex()+" GP: "+node.getGraphPerspectiveIndex() );		// get and reset the change event.		ChangeEvent event = getChangeEvent();		event.reset();		int index = node.getGraphPerspectiveIndex();		nodeSelectionList.put(index, 1);		noNodeSelection = false;		event.addSelectedNodeIndex(node.getRootGraphIndex());		// fire the Event		if (event != null) fireGraphViewChanged(event);	}	public void nodeUnselected(PNodeView node)	{		ChangeEvent event = getChangeEvent();		event.reset();		int index = node.getGraphPerspectiveIndex();		nodeSelectionList.put(index, 0);		noNodeSelection = false;		event.addUnselectedNodeIndex(node.getRootGraphIndex());		// fire the Event		if (event != null) fireGraphViewChanged(event);	}	public void edgeSelected(PEdgeView edge)	{		// get and reset the change event.		ChangeEvent event = getChangeEvent();		event.reset();		int index = edge.getGraphPerspectiveIndex();		edgeSelectionList.put(index, 1);		noEdgeSelection = false;		// add newly selected node/edges to the event		event.addSelectedEdgeIndex(edge.getRootGraphIndex());		// fire the Event		if (event != null) fireGraphViewChanged(event);	}	public void edgeUnselected(PEdgeView edge)	{		// get and reset the change event.		ChangeEvent event = getChangeEvent();		event.reset();		int index = edge.getGraphPerspectiveIndex();		edgeSelectionList.put(index, 0);		// event.addUnselectedEdge( getGraphPerspective().getEdge( (		// (PEdgeView)edge).getGraphPerspectiveIndex() ) );		event.addUnselectedEdgeIndex(edge.getRootGraphIndex());		// fire the Event		if (event != null) fireGraphViewChanged(event);	}	protected void clearNodeSelectionList()	{		nodeSelectionList = new HashMap<Integer, Integer>(getGraphPerspective()				.getNodeCount());	}	protected void ensureNodeSelectionCapacity()	{		if (nodeSelectionList == null)		{			nodeSelectionList = new HashMap<Integer, Integer>(getGraphPerspective()					.getNodeCount());		} //		else//		{//			nodeSelectionList.ensureCapacity(getGraphPerspective()//					.getNodeCount());//		}	}	protected void clearEdgeSelectionList()	{		edgeSelectionList = new HashMap<Integer, Integer>(getGraphPerspective()				.getEdgeCount());	}	protected void ensureEdgeSelectionCapacity()	{		if (edgeSelectionList == null)		{			edgeSelectionList = new HashMap<Integer, Integer>(getGraphPerspective()					.getEdgeCount());		}	}		/**	 * @return an int array of the graph perspective indices of the selected	 * nodes	 */	public int[] getSelectedNodeIndices()	{		List<PNodeView> selected = getSelectedNodes();		int[] res = new int[selected.size()];		int j = 0;		for( Iterator<PNodeView> it = selected.iterator(); it.hasNext(); j++)			res[j] = it.next().getNode().getRootGraphIndex();		return res;	}	/**	 * 	 * @return a list of the selected PNodeView	 * 	 */	public List<PNodeView> getSelectedNodes()	{    		ArrayList<PNodeView> selected = new ArrayList<PNodeView>(				  nodeSelectionList.size());		for (Iterator it = getGraphPerspective().nodesIterator(); it.hasNext(); )		{   int idx = ((FNode) it.next()).getRootGraphIndex();			if (nodeSelectionList.containsKey(idx)					&& nodeSelectionList.get(idx) == 1)				selected.add(getNodeView(idx));		}		return selected;	}	/**	 * 	 * @return an int array of the graph perspective indices of the selected	 * edges	 * 	 */	public int[] getSelectedEdgeIndices()	{		List<PEdgeView> selected = getSelectedEdges();		int[] res = new int[selected.size()];		int j = 0;		for( Iterator<PEdgeView> it = selected.iterator(); it.hasNext(); j++)			res[j] = it.next().getEdge().getRootGraphIndex();		return res;	}	/**	 * 	 * @return a list of the selected PEdgeView	 * 	 */	public List<PEdgeView> getSelectedEdges()	{		ArrayList<PEdgeView> selected = new ArrayList<PEdgeView>(				edgeSelectionList.size());		for (Iterator<FEdge> it = getGraphPerspective().edgesIterator(); it.hasNext(); )		{   int idx = it.next().getRootGraphIndex();			if (edgeSelectionList.containsKey(idx)					&& edgeSelectionList.get(idx) == 1)				selected.add(getEdgeView(idx));		}		return selected;	}	public void prepareToPrint()	{		getCanvas().getCamera().addClientProperty(				PrintingFixTextNode.PRINTING_CLIENT_PROPERTY_KEY, "true");	}	public void donePrinting()	{		getCanvas().getCamera().addClientProperty(				PrintingFixTextNode.PRINTING_CLIENT_PROPERTY_KEY, null);	}	public double getWidth()	{		return getCanvas().getWidth();	}	public double getHeight()	{		return getCanvas().getHeight();	}	// -------------------------------------------------------------------------//	// GraphViewChangeEvent methods	// -------------------------------------------------------------------------//	public void addGraphViewChangeListener(GraphViewChangeListener listener)	{		listenerList.add(GraphViewChangeListener.class, listener);	} // addRootGraphChangeListener( RootGraphChangeListener )	public void removeGraphViewChangeListener(GraphViewChangeListener listener)	{		listenerList.remove(GraphViewChangeListener.class, listener);	} // removeRootGraphChangeListener( RootGraphChangeListener )	protected void fireGraphViewChanged(ChangeEvent event)	{		// Guaranteed to return a non-null array		Object[] listeners = listenerList.getListenerList();		// Process the listeners last to first, notifying		// those that are interested in this event		for (int i = (listeners.length - 2); i >= 0; i -= 2)		{			if (listeners[i] == GraphViewChangeListener.class)			{				((GraphViewChangeListener) listeners[i + 1])						.graphViewChanged(event);			}		}		event.reset();	} // fireRootGraphChanged( ChangeEvent )	protected ChangeEvent getChangeEvent()	{		// TODO: Handle multithreading n stuff		if (phoebeGraphViewChangeEvent == null)		{			phoebeGraphViewChangeEvent = createChangeEvent();		}		return phoebeGraphViewChangeEvent;	} // getChangeEvent()	protected ChangeEvent createChangeEvent()	{		return new ChangeEvent();	} // createChangeEvent();	/**	 * 	 * @param the new Paint for the background	 * 	 */	public void setBackgroundPaint(Paint paint)	{		getCanvas().getCamera().setPaint(paint);	}	/**	 * 	 * @return the backgroundPaint	 * 	 */	public Paint getBackgroundPaint()	{		return getCanvas().getCamera().getPaint();	}	// ----------------------------------------//	// Event Handlers	// ----------------------------------------//	public boolean nodeSelectionEnabled()	{		return nodeSelection;	}	public boolean edgeSelectionEnabled()	{		return edgeSelection;	}	public void enableNodeSelection()	{		if (!nodeSelection)		{			getCanvas().addInputEventListener(getSelectionHandler());		}		nodeSelection = true;	}	public void disableNodeSelection()	{		if (nodeSelection)		{			getCanvas().removeInputEventListener(getSelectionHandler());		}		nodeSelection = false;	}	/**	 * 	 * @return The Selection Handler	 * 	 */	public PSelectionHandler getSelectionHandler()	{		return selectionHandler;	}	public void enableEdgeSelection()	{		if (!edgeSelection)		{			getCanvas().addInputEventListener(getEdgeSelectionHandler());		}		edgeSelection = true;	}	public void disableEdgeSelection()	{		if (edgeSelection)		{			getCanvas().removeInputEventListener(getEdgeSelectionHandler());		}		edgeSelection = false;	}	public PEdgeSelectionHandler getEdgeSelectionHandler()	{		return edgeSelectionHandler;	}	public void enablePanning()	{		getCanvas().addInputEventListener(getCanvas().getPanEventHandler());	}	public void disablePanning()	{		getCanvas().removeInputEventListener(getCanvas().getPanEventHandler());	}	/**	 * 	 * @return the Squiggle Event Handler	 * 	 */	public SquiggleEventHandler getSquiggleHandler()	{		return squiggleEventHandler;	}	public void openNodeEditor(PNodeView nv)	{		// if ( nodeEditor == null ) {		// nodeEditor = new PNodeViewEditor( this );		// }		// nodeEditor.setCurrentNode( nv );		// nodeEditor.setVisible( true );	}	/**	 * 	 * This BirdsEyeView only looks at the nodes.	 * 	 * @return The BirdsEyeView that needs to be put into a frame/dialog/pane	 * 	 */	public JComponent getBirdsEyeView()	{		// PCanvasReferencia canvas = new PCanvasReferencia( getCanvas(),		// nodeLayer );		// canvas.setSize( 200, 200 );		// canvas.getCamera().animateViewToCenterBounds(		// canvas.getLayer().getGlobalFullBounds(), true, 0 );		// canvas.setBorder( BorderFactory.createLineBorder( Color.black ) );		BirdsEyeView canvas = new BirdsEyeView();		canvas.connect(getCanvas(), new PLayer[] { getCanvas().getLayer() });		return canvas;	}	/**	 * 	 * @return the java.awt.Component that can be added to most screen thingys	 * 	 */	public Component getComponent()	{		return viewComponent;	}	/**	 * 	 * @return The Piccolo PCanvas that the Graph is Drawn on	 * 	 */	public PCanvas getCanvas()	{		return canvas;	}	/**	 * 	 * @return The PLayer that all Nodes are added to	 * 	 */	public PLayer getNodeLayer()	{		return nodeLayer;	}	/**	 * 	 * @return The PLayer that all Edges are added to	 * 	 */	public PLayer getEdgeLayer()	{		return edgeLayer;	}	/**	 * 	 * @return The PLayer that all non-FNode and non-FEdge objects can be added to	 * 	 */	public PLayer getObjectLayer()	{		return objectLayer;	}	/**	 * 	 * @param node Access to adding a FNode to the Graph	 * 	 */	public void addToNodeLayer(PNode node)	{		nodeLayer.addChild(node);	}	/**	 * 	 * @param edge Access to adding an FEdge to the Graph	 * 	 */	public void addToEdgeLayer(PNode edge)	{		edgeLayer.addChild(edge);		// Iterator ci = edgeLayer.getChildrenIterator();		// System.out.println( "Adding to FEdge Layer: "+edge );		// System.out.println( "EdgeLayer now has		// "+edgeLayer.getChildrenCount()+" children." );		// while ( ci.hasNext() ) {		// System.out.println( " child: "+ci.next() );		// }	}	/**	 * 	 * This method will create a Viewable PNode derivative for every node	 * 	 * and FEdge in the GraphPerspective	 * 	 */	protected void createViewableObjects()	{		firePiccoloEvents = false;		long time = System.currentTimeMillis();		// Get the FNode Indicies of the Perspecitve		// They will be mapped by RootGraph index ( negative number ) to the		// PNode		int[] node_indices = perspective.getNodeIndicesArray();		PNodeView node_view;		// System.out.println( "There are "+node_indices.length+" nodes. ");		ArrayList node_view_list = new ArrayList(node_indices.length);		for (int index = 0; index < node_indices.length; ++index)		{			// System.out.println( "Creating a PNodeView for: "+ index + "			// mapped to: "+node_indices[index] );			// Add Nodes in a Default Layout			// TODO: Remove?			if (DEFAULT_X % 2000 == 0)			{				DEFAULT_Y += 100;				DEFAULT_X = 100;			} else			{				DEFAULT_X += 100;			}			// Only need to Change the X and Y			NODE_DEFAULTS[0] = new Double(DEFAULT_X);			NODE_DEFAULTS[1] = new Double(DEFAULT_Y);			setAllNodePropertyData(node_indices[index],					(Object[]) NODE_DEFAULTS.clone());			node_view = new PNodeView(node_indices[index], this);			// System.out.println( "Putting NOde: "+node_indices[index] );			nodeViewMap.put(node_indices[index], node_view);			node_view_list.add(node_view);			addToNodeLayer(node_view);		}		System.out.println("Create Nodes took: "				+ (System.currentTimeMillis() - time));		// add all nodes to the layer at once		// nodeLayer.addChildren( node_view_list );		// new, faster? implementation....		PEdgeView edge_view;		int source_index, target_index;		//int[] edge_indices = perspective.getEdgeIndicesArray();		ArrayList edge_view_list = new ArrayList();		for (Iterator it = perspective.edgesIterator(); it.hasNext();)		{			int idx = ((FEdge) it.next()).getRootGraphIndex();			source_index = perspective.getEdgeSourceIndex(idx);			target_index = perspective.getEdgeTargetIndex(idx);			EDGE_DEFAULTS[0] = new Integer(source_index);			EDGE_DEFAULTS[1] = new Integer(target_index);			setAllEdgePropertyData(idx, (Object[]) EDGE_DEFAULTS					.clone());			edge_view = new PEdgeView(idx, this);			addToEdgeLayer(edge_view);			edge_view_list.add(edge_view);			edgeViewMap.put(idx, edge_view);		}		// edgeLayer.addChildren( edge_view_list );		firePiccoloEvents = true;		System.out.println("Create Viewable Object took: "				+ (System.currentTimeMillis() - time));	}	/**	 * 	 * @param node_index the index of a node to have a view created for it	 * 	 * @return a new PNodeView based on the node with the given index	 * 	 */	public PNodeView addNodeView(int node_index)	{		ensureNodeSelectionCapacity();		if (node_index > 0)		{			node_index = getGraphPerspective()					.getRootGraphNodeIndex(node_index);		}		if (DEFAULT_X % 2000 == 0)		{			DEFAULT_Y += 100;			DEFAULT_X = 100;		} else		{			DEFAULT_X += 100;		}		// Only need to Change the X and Y		NODE_DEFAULTS[0] = new Double(DEFAULT_X);		NODE_DEFAULTS[1] = new Double(DEFAULT_Y);		// NODE_DEFAULTS[ NODE_PAINT ] = java.awt.Color.orange;		setAllNodePropertyData(node_index, (Object[]) NODE_DEFAULTS.clone());		PNodeView node_view = new PNodeView(node_index, this);		nodeViewMap.put(node_index, node_view);		addToNodeLayer(node_view);		return node_view;	}	/**	 * 	 * @param edge_index the index of an edge	 * 	 * @return the newly created edgeview	 * 	 */	public PEdgeView addEdgeView(int edge_index)	{		ensureEdgeSelectionCapacity();		if (edge_index > 0)		{			edge_index = getGraphPerspective()					.getRootGraphEdgeIndex(edge_index);		}		EDGE_DEFAULTS[0] = new Integer(getGraphPerspective().getRootGraph()				.getEdgeSourceIndex(edge_index));		EDGE_DEFAULTS[1] = new Integer(getGraphPerspective().getRootGraph()				.getEdgeTargetIndex(edge_index));		setAllEdgePropertyData(edge_index, (Object[]) EDGE_DEFAULTS.clone());		PEdgeView edge_view = new PEdgeView(edge_index, this);		addToEdgeLayer(edge_view);		// getCanvas().getLayer().addChild( edge_view );		edgeViewMap.put(edge_index, edge_view);		return edge_view;	}	/**	 * 	 * To facilitate adding Custome EdgeViews	 * 	 * It is recomended that All Custom FEdge Views follow the patterns outlined	 * 	 * in PEdgeView and BasicPEdgeView.	 * 	 * @param class_name the name of the class that implements PEdgeView and	 * esnted PEdge	 * 	 * @param edge_index the index of the edge	 * 	 */	public PEdgeView addEdgeView(String class_name, int edge_index)	{		ensureEdgeSelectionCapacity();		PEdgeView edge_view = null;		try		{			// Get the Class and The Constructor			Class custom_class = Class.forName(class_name);			Class[] types = new Class[] { int.class, PGraphView.class };			if (edge_index > 0)			{				edge_index = getGraphPerspective().getRootGraphEdgeIndex(						edge_index);			}			EDGE_DEFAULTS[0] = new Integer(getGraphPerspective().getRootGraph()					.getEdgeSourceIndex(edge_index));			EDGE_DEFAULTS[1] = new Integer(getGraphPerspective().getRootGraph()					.getEdgeTargetIndex(edge_index));			setAllEdgePropertyData(edge_index, (Object[]) EDGE_DEFAULTS.clone());			Object[] values = new Object[] { new Integer(edge_index), this };			Constructor custom_constructor = custom_class.getConstructor(types);			edge_view = (PEdgeView) custom_constructor.newInstance(values);			edgeViewMap.put(edge_index, edge_view);			addToEdgeLayer(edge_view);		}		catch (Exception ex)		{			ex.printStackTrace();		}		return edge_view;	}	/**	 * 	 * To facilitate adding Custome NodeViews	 * 	 * It is recomended that All Custom FNode Views follow the patterns outlined	 * 	 * in PNodeView and BasicPNodeView.	 * 	 * @param class_name the name of the class that implements PNodeView and	 * esnted PNode	 * 	 * @param node_index the index of the node	 * 	 */	public PNodeView addNodeView(String class_name, int node_index)	{		ensureNodeSelectionCapacity();		PNodeView node_view = null;		try		{			// Get the Class and The Constructor			Class custom_class = Class.forName(class_name);			Class[] types = new Class[] { int.class, PGraphView.class };			if (node_index > 0)			{				node_index = getGraphPerspective().getRootGraphNodeIndex(						node_index);			}			if (nodeViewMap.get(node_index) != null)			{				// Create and add the new node.				nodeLayer.removeChild((PNode) nodeViewMap.get(node_index));				Object[] values = new Object[] { new Integer(node_index), this };				Constructor custom_constructor = custom_class						.getConstructor(types);				node_view = (PNodeView) custom_constructor.newInstance(values);				nodeViewMap.put(node_index, node_view);				addToNodeLayer(node_view);				// update connections				PEdgeView edge;				int[] neighbors = getGraphPerspective().neighborsArray(						node_index);				// System.out.println( "Update connections for node:				// "+node_index );				for (int i = 0; i < neighbors.length; ++i)				{					// System.out.println( "Get Edges between: "+node_index+"					// and "+neighbors[i] );					int[] edge_array = getGraphPerspective()							.getAdjacentEdgeIndicesArray(node_index, true, true, true);					if (edge_array != null)					{						for (int j = 0; j < edge_array.length; ++j)						{							// System.out.println( "Get FEdge View for edge:							// "+edge_array[j]+" J: "+j );							edge = (PEdgeView) getEdgeView(edge_array[j]);							edge.updateConnection(getGraphPerspective()									.getRootGraphNodeIndex(node_index));						}					}				}			} else			{				if (DEFAULT_X % 2000 == 0)				{					DEFAULT_Y += 100;					DEFAULT_X = 100;				} else				{					DEFAULT_X += 100;				}				// Only need to Change the X and Y				NODE_DEFAULTS[0] = new Double(DEFAULT_X);				NODE_DEFAULTS[1] = new Double(DEFAULT_Y);				setAllNodePropertyData(node_index, (Object[]) NODE_DEFAULTS						.clone());				Object[] values = new Object[] { new Integer(node_index), this };				Constructor custom_constructor = custom_class						.getConstructor(types);				node_view = (PNodeView) custom_constructor.newInstance(values);				nodeViewMap.put(node_index, node_view);				addToNodeLayer(node_view);			}		}		catch (Exception ex)		{			ex.printStackTrace();		}		return (PNodeView) node_view;	}	/**	 * 	 * Add in a PNodeView for a FNode in the GraphPerspective.	 * 	 * Note that this means that if there already was a PNodeView for this node,	 * 	 * the new PNodeView will take its place.	 * 	 * @return If it is replacing, it returns the <B>old</B> PNodeView.	 * 	 * @return If it is new, it returns the <B>new</b> PNodeView.	 * 	 */	public PNodeView addNodeView(int node_index, PNodeView node_view_replacement)	{		ensureNodeSelectionCapacity();		PNodeView node_view;		if (node_index > 0)		{			node_index = getGraphPerspective()					.getRootGraphNodeIndex(node_index);		}		if (node_view_replacement instanceof PNode != true)		{			return null;		} else		{			node_view = (PNodeView) node_view_replacement;		}		if (nodeViewMap.get(node_index) != null)		{			// Create and add the new node.			nodeLayer.removeChild((PNode) nodeViewMap.get(node_index));			nodeViewMap.put(node_index, node_view);			addToNodeLayer(node_view);			// update connections			PEdgeView edge;			int[] neighbors = getGraphPerspective().neighborsArray(node_index);			// System.out.println( "Update connections for node: "+node_index );			for (int i = 0; i < neighbors.length; ++i)			{				// System.out.println( "Get Edges between: "+node_index+" and				// "+neighbors[i] );				int[] edge_array = getGraphPerspective().getAdjacentEdgeIndicesArray(						node_index, true, true, true);				if (edge_array != null)				{					for (int j = 0; j < edge_array.length; ++j)					{						// System.out.println( "Get FEdge View for edge:						// "+edge_array[j]+" J: "+j );						edge = (PEdgeView) getEdgeView(edge_array[j]);						if (edge != null)							edge.updateConnection(getGraphPerspective()									.getRootGraphNodeIndex(node_index));					}				}			}		} else		{			// Just add the node			nodeViewMap.put(node_index, node_view);			addToNodeLayer(node_view);		}		return (PNodeView) node_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PNodeView removeNodeView(PNodeView node_view)	{		try		{			((PNode) node_view).removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: "+			// node_view );			return null;		}		nodeViewMap.remove(perspective.getRootGraphNodeIndex(node_view				.getGraphPerspectiveIndex()));		ensureNodeSelectionCapacity();		nodeSelectionList.put(node_view.getGraphPerspectiveIndex(), 0);		return node_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PNodeView removeNodeView(FNode node)	{		PNodeView node_view = (PNodeView) getNodeView(node);		try		{			node_view.removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: "+ node);			return null;		}		nodeViewMap.remove(perspective.getRootGraphNodeIndex(node_view				.getGraphPerspectiveIndex()));		ensureNodeSelectionCapacity();		nodeSelectionList.put(node_view.getGraphPerspectiveIndex(), 0);		return node_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PNodeView removeNodeView(int node)	{		PNodeView node_view = (PNodeView) getNodeView(node);		try		{			node_view.removeFromParent();		}		catch (Exception e)		{			// System.out.println( "GINY at PGraphView.removeNodeView(int):			// Parent was most likely null for: "+node);			return null;		}		nodeViewMap.remove(perspective.getRootGraphNodeIndex(node_view				.getGraphPerspectiveIndex()));		ensureNodeSelectionCapacity();		nodeSelectionList.put(node_view.getGraphPerspectiveIndex(), 0);		return node_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PEdgeView removeEdgeView(PEdgeView edge_view)	{		try		{			((PNode) edge_view).removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: " +			// edge_view );			return null;		}		edgeViewMap.remove(perspective.getRootGraphEdgeIndex(edge_view				.getGraphPerspectiveIndex()));		ensureEdgeSelectionCapacity();		edgeSelectionList.put(edge_view.getGraphPerspectiveIndex(), 0);		return edge_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PEdgeView removeEdgeView(FEdge edge)	{		PEdgeView edge_view = (PEdgeView) getEdgeView(edge);		try		{			edge_view.removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likely null for: " + edge );			return null;		}		edgeViewMap.remove(perspective.getRootGraphEdgeIndex(edge_view				.getGraphPerspectiveIndex()));		ensureEdgeSelectionCapacity();		edgeSelectionList.put(edge_view.getGraphPerspectiveIndex(), 0);		return edge_view;	}	/**	 * 	 * This will entirely remove a PNodeView/PEdgeView from the GraphView. This is	 * different than	 * 	 * @see{hideGraphObject} as that method simply stops showing the node/edge.	 * This method	 * 	 * will destroy the object. It will be returned though, so that a reference	 * can be kept	 * 	 * for undo purposes.	 * 	 */	public PEdgeView removeEdgeView(int edge)	{		PEdgeView edge_view = (PEdgeView) getEdgeView(edge);		try		{			edge_view.removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: " + edge);			return null;		}		if (edge < 0)		{			edgeViewMap.remove(edge);		} else		{			edgeViewMap.remove(perspective.getRootGraphEdgeIndex(edge_view							.getGraphPerspectiveIndex()));		}		ensureEdgeSelectionCapacity();		edgeSelectionList.put(edge_view.getGraphPerspectiveIndex(), 0);		return edge_view;	}	/**	 * 	 * @return The Unique Identifier of this GraphView	 * 	 */	public String getIdentifier()	{		return identifier;	} // getIdentifier()	/**	 * 	 * @param new_identifier The New Identifier for this GraphView	 * 	 */	public void setIdentifier(String new_identifier)	{		if (identifier == null)		{			if (new_identifier == null)			{				return;			}		} else if (new_identifier != null)		{			if (identifier.equals(new_identifier))			{				return;			}		}		String old_identifier = identifier;		identifier = new_identifier;		pcs.firePropertyChange("identifier", old_identifier, new_identifier);	} // setIdentifier(..)	/**	 * 	 * @return The Current Zoom Level	 * 	 */	public double getZoom()	{		return getCanvas().getCamera().getViewScale();	}	/**	 * 	 * @param d The New ZoomLevel	 * 	 */	public void setZoom(double d)	{		// PBounds bounds = getCanvas().getCamera().getViewBounds();		// double x = bounds.getX();		// double y = bounds.getY();		// double h = bounds.getHeight();		// double w = bounds.getWidth();		java.awt.geom.Point2D point = getCanvas().getCamera().getBounds()				.getCenter2D();		point = getCanvas().getCamera().localToView(point);		getCanvas().getCamera().scaleViewAboutPoint(d, point.getX(),				point.getY());		// getCanvas().getCamera() .scaleViewAboutPoint( d, x + ( w - x ) /2 , y		// + ( h -y ) /2 );		// System.out.println( "X: "+x+" Y: "+y+" H: "+h+" W: "+w );		// PNode node = new PNode();		// node.setPaint( Color.red );		// getCanvas().getLayer().addChild( node );		// node.setOffset( x + ( w - x ) /2 , y + ( h -y ) /2 );	}	/**	 * 	 * Fits all Viewable elements onto the Graph	 * 	 */	public void fitContent()	{		SwingUtilities.invokeLater(new Runnable() {			public void run()			{				getCanvas().getCamera().animateViewToCenterBounds(						getCanvas().getLayer().getFullBounds(), true, 500l);				if (getCanvas().getCamera().getViewScale() < .45)				{					// getCanvas().setDefaultRenderQuality(PPaintContext.LOW_QUALITY_RENDERING);				}			}		});		// System.out.println( "Fitting Content: "+		// getCanvas().getLayer().getFullBounds() );		// try {		// PTransformActivity activity =		// getCanvas().getCamera().animateViewToCenterBounds(		// getCanvas().getLayer().getGlobalFullBounds(), true, 500l );		// getCanvas().getCamera().addActivity( activity );		// } catch ( Exception e ) {		// oh yes, this is hacky.		// }	}	/**	 * 	 * Do a global redraw of the entire canvas	 * 	 */	public void updateView()	{		// getCanvas().getCamera().repaint();	}	// implements GraphView	public FRootGraph getRootGraph()	{		return perspective.getRootGraph();	}	// private PEdgeView createEdgeView(	// FEdge graph_edge,	// int source_index,	// int target_index) {	// PNodeView source_node_view = (PNodeView) matrix.get(source_index,	// source_index);	// PNodeView target_node_view = (PNodeView) matrix.get(target_index,	// target_index);	// // Unhackify TODO	// PEdgeView graph_edge_view = new PEdgeView(graph_edge, this,	// source_node_view, target_node_view, true);	// //PEdgeView graph_edge_view = new PEdgeView( graph_edge, this,	// source_node_view, target_node_view, perspective.isLargeGraph() );	// getCanvas()	// .getLayer()	// .addChild(graph_edge_view);	// //addToEdgeLayer( graph_edge_view );	// // graph_edge_view.moveToBack();	// // edgeNode.invalidateFullBounds();	// //edgeNode.invalidateFullBounds();	// //edgeNode.repaint();	// return graph_edge_view;	// }	// private PEdgeView createEdgeView(	// FEdge graph_edge,	// int source_index,	// int target_index,	// boolean largeGraph) {	// PNodeView source_node_view = (PNodeView) matrix.get(source_index,	// source_index);	// PNodeView target_node_view = (PNodeView) matrix.get(target_index,	// target_index);	// // unhackify TODO	// PEdgeView graph_edge_view = new PEdgeView(graph_edge, this,	// source_node_view, target_node_view, true);	// //PEdgeView graph_edge_view = new PEdgeView( graph_edge, this,	// source_node_view, target_node_view, perspective.isLargeGraph() );	// getCanvas()	// .getLayer()	// .addChild(graph_edge_view);	// //addToEdgeLayer( graph_edge_view );	// // graph_edge_view.moveToBack();	// edgeNode.invalidateFullBounds();	// edgeNode.repaint();	// return graph_edge_view;	// }	/**	 * nodeViewsList only returns the NodeViews that are explicitly associated	 * with this GraphView	 */	public List<PNodeView> getNodeViewsList()	{		ArrayList<PNodeView> list = new ArrayList<PNodeView>(getNodeViewCount());		int[] gp_indices = perspective.getNodeIndicesArray();		for (int i = 0; i < gp_indices.length; ++i)			list.add(getNodeView(gp_indices[i]));		return list;	}	/**	 * nodeViewsIterator only returns the NodeViews that are explicitly	 * associated with this GraphView	 * 	 */	public Iterator<PNodeView> getNodeViewsIterator()	{		return getNodeViewsList().iterator();	}	/**	 * 	 * 	 * 	 */	public int getNodeViewCount()	{		return perspective.getNodeCount();	}	/**	 * 	 * 	 * 	 */	public int getEdgeViewCount()	{		return perspective.getEdgeCount();	}	/**	 * 	 * @param node The FNode whose view is requested	 * 	 * 	 * 	 * @return The PNodeView of the given FNode	 * 	 */	public PNodeView getNodeView(FNode node)	{		// int i = model2view( node.getIndex() );		// System.out.println( "PGRAPHVIEW: Getting PNodeView for node:		// "+node.getIdentifier()+", "+ perspective.getIndex( node ) );		// return (PNodeView) nodeViewMap.get( perspective.getIndex( node ) );		return getNodeView(node.getRootGraphIndex());	}	/**	 * 	 * @param index the index of the node whose view is requested	 * 	 * @return The PNodeView of the given FNode	 * 	 */	public PNodeView getNodeView(int index)	{		// System.out.println( "PGRAPHVIEW: Getting PNodeView for index: "+index		// );		if (index > 0)		{			// System.out.println( "PGRAPHVIEW: converting to RootGraphIndex:			// "+perspective.getRootGraphNodeIndex( index ) );			return (PNodeView) nodeViewMap.get(perspective					.getRootGraphNodeIndex(index));		} else		{			// index is negative, so we must be the root graph index we are			// keyed off			// System.out.println( "PGRAPHVIEW: No need to convert: "+index );			return (PNodeView) nodeViewMap.get(index);		}	}	/**	 * 	 * Return all of the EdgeViews in this GraphView	 * 	 */	public java.util.List getEdgeViewsList()	{		ArrayList list = new ArrayList();		for (Iterator it = perspective.edgesIterator(); it.hasNext();)		{			int idx = ((FEdge) it.next()).getRootGraphIndex();			list.add(getEdgeView(idx));		}		return list;	}	/**	 * 	 * Note that this will return a list of FEdge objects, the other one will	 * return indices	 * 	 * @return The list of EdgeViews connecting these two nodes. Possibly null.	 * 	 */	public java.util.List getEdgeViewsList(FNode oneNode, FNode otherNode)	{		int[] edges = perspective.getAdjacentEdgeIndicesArray(				oneNode.getRootGraphIndex(),true, true, true);		if (edges == null || edges.length == 0) return null;		java.util.List edgeViews = new ArrayList();		for(int i = 0; i< edges.length; i++)		{			FEdge e = (FEdge) perspective.getEdge(edges[i]);			edgeViews.add(getEdgeView(e));		}		if (edgeViews.size() > 0)			return edgeViews;		else			return null;	}	/**	 * 	 * @return a List of indicies	 * 	 */	public java.util.List getEdgeViewsList(int from_node_index,			int to_node_index, boolean include_undirected_edges)	{		int[] edges = perspective.getAdjacentEdgeIndicesArray(				from_node_index,true, true, true);		if (edges == null || edges.length == 0) return null;				ArrayList view_list = new ArrayList();		for (int i = 0; i < edges.length; i++)			view_list.add(getEdgeView(edges[i]));		return view_list;	}	public PEdgeView getEdgeView(int edge_index)	{		if (edge_index > 0)		{			edge_index = perspective.getRootGraphEdgeIndex(edge_index);			return edgeViewMap.get(edge_index);		} else		{			return edgeViewMap.get(edge_index);		}	}	/**	 * 	 * Return all of the EdgeViews in this GraphView	 * 	 */	public Iterator getEdgeViewsIterator()	{		return getEdgeViewsList().iterator();	}	// implements GraphView	public PEdgeView getEdgeView(FEdge edge)	{		return edgeViewMap.get(edge.getRootGraphIndex());	}				/**	 * 	 * Hides an Object that is in the Graph by removing it from the	 * 	 * Piccolo Scene Graph	 * 	 * <B>Note:</B> The object must inherit from	 * 	 * @see PNode	 * 	 * @see PGraphView#hideNodeView( PNodeView )	 * 	 * @see PGraphView#hideNodeView( PNodeView, boolean )	 * 	 */	public boolean hideGraphObject(Object object)	{		// An object needs to be passed since PNodeView and PEdgeView interfaces		// do not extend from PNode, even though their implementations do.		PNode obj = (PNode) object;		try		{			((PNode) object).removeFromParent();		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: "+object			// );			return false;		}		return true;		// if ( obj.getParent() != null ) {		// obj.removeFromParent();		// return true;		// }		// parent was null, which means the object was already removed		// return false;	}	/**	 * 	 * Shows an Object that is in the Graph by addng it to the	 * 	 * Piccolo Scene Graph	 * 	 * <B>Note:</B> The object must inherit from	 * 	 * @see PNode	 * 	 */	public boolean showGraphObject(Object object)	{		if (object == null)		{			// System.out.println( "Object was Null" );			return false;		}		PNode obj = (PNode) object;		// System.out.println( "Showing: "+object );		try		{			if (obj.getParent() != null)			{				// System.out.println( "Object parent for: "+obj+" was not				// null." );				return false;			}		}		catch (Exception e)		{			// System.out.println( "Parent was most likeley null for: "+object			// );			return false;		}		if (object instanceof PNodeView)		{			// its a node, should be on the node layer			nodeLayer.addChild((PNode) object);			return true;		} else if (object instanceof PEdgeView)		{			// its an edge			edgeLayer.addChild((PNode) object);			return true;		} else		{			return false;		}	}	/**	 * 	 * Hides a group of GraphObjects	 * 	 */	public boolean hideGraphObjects(List objects)	{		Iterator pnodes = objects.iterator();		while (pnodes.hasNext())		{			hideGraphObject((PNode) pnodes.next());		}		return true;	}	// ----------------------------------------//	// Context Menu Stuff	public Object[] getContextMethods(String class_name, boolean plus_superclass)	{		if (class_name.startsWith("class "))		{			class_name = class_name.substring(6, class_name.length());		}		if (plus_superclass)		{			try			{				return getContextMethods(class_name, null);			}			catch (Exception ex)			{				System.out.println("Exception encounterd getting methods");				ex.printStackTrace();				return null;			}		}		return (Object[]) contextMenuStore.get(class_name);	}	public Object[] getContextMethods(String class_name, Object[] methods)	{		if (class_name.startsWith("class "))		{			class_name = class_name.substring(6, class_name.length());		}		try		{			Class c = Class.forName(class_name);			if (methods == null)			{				methods = (Object[]) contextMenuStore.get(class_name);			} else			{				Object[] new_methods = (Object[]) contextMenuStore						.get(class_name);				if (new_methods != null)				{					// we need to tack onto methods					Object[] return_methods = new Object[new_methods.length							+ methods.length];					System.arraycopy(methods, 0, return_methods, 0,							methods.length);					System.arraycopy(new_methods, 0, return_methods,							methods.length, new_methods.length);					methods = return_methods;				}			}			// Class[] interfaces = c.getInterfaces();			// for ( int i = 0; i < interfaces.length; ++i ) {			// methods = getContextMethods( interfaces[i].getName(), methods );			// }			Class sc = c.getSuperclass();			if (!sc.getName().equals("java.lang.Object"))			{				return getContextMethods(sc.getName(), methods);			} else			{				return methods;			}		}		catch (Exception exc)		{			exc.printStackTrace();			return methods;		}	}	/**	 * 	 * @param class_name This is the class that should get this method in its	 * ContextMenu	 * 	 * @param method_class_name the name of the class that contains the method	 * 	 * @param method_name the name of the method	 * 	 * @param args every method will take both an Object[] of whatever, and a	 * PNode	 * 	 */	public boolean addContextMethod(String class_name,			String method_class_name, String method_name, Object[] args,			ClassLoader loader)	{		if (class_name.startsWith("class "))		{			class_name = class_name.substring(6, class_name.length());		}		Object old_store = (Object) contextMenuStore.get(class_name);		Object[] new_store;		if (old_store == null)		{			// no methods previously existed for this type of class			new_store = new Object[] { new Object[] { method_class_name,					method_name, args, loader } };		} else		{			Object[] store = (Object[]) old_store;			new_store = new Object[store.length + 1];			System.arraycopy(store, 0, new_store, 0, store.length);			new_store[store.length] = new Object[] { method_class_name,					method_name, args, loader };		}		contextMenuStore.put(class_name, new_store);		return true;	}	// ----------------------------------------//	// Change Event	protected class ChangeEvent extends GraphViewChangeEvent	{		protected int type;		protected int[] restoredNodeIndices;		protected int[] restoredEdgeIndices;		protected int[] hiddenNodeIndices;		protected int[] hiddenEdgeIndices;		protected int[] selectedNodeIndices;		protected int[] unselectedNodeIndices;		protected int[] selectedEdgeIndices;		protected int[] unselectedEdgeIndices;		protected FNode[] restoredNodes;		protected FEdge[] restoredEdges;		protected FNode[] hiddenNodes;		protected FEdge[] hiddenEdges;		protected FNode[] selectedNodes;		protected FNode[] unselectedNodes;		protected FEdge[] selectedEdges;		protected FEdge[] unselectedEdges;		ChangeEvent()		{			super(PGraphView.this);			reset();		}		public void reset()		{			type = 0;			restoredNodeIndices = null;			restoredEdgeIndices = null;			hiddenNodeIndices = null;			hiddenEdgeIndices = null;			restoredNodes = null;			restoredEdges = null;			hiddenNodes = null;			hiddenEdges = null;		} // reset()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. Changes may be		 * any		 * 		 * combination of the following types:		 * 		 * <ul>		 * 		 * <li> NODES_RESTORED_TYPE </li>		 * 		 * <li> EDGES_RESTORED_TYPE </li>		 * 		 * <li> NODES_HIDDEN_TYPE </li>		 * 		 * <li> EDGES_HIDDEN_TYPE </li>		 * 		 * </ul>		 * 		 * The <tt>type</tt> of a GraphPerspectiveChangeEvent is the boolean		 * AND (the & operation) of these types, which are conveniently distinct		 * powers of		 * 		 * two. As shortcuts we also provide the methods {@link		 * 		 * #isNodesRestoredType()}, {@link #isEdgesRestoredType()}, {@link		 * 		 * #isNodesHiddenType()}, and {@link #isEdgesHiddenType()}.		 * 		 * @return the type of this Event		 * 		 * @see #isNodesRestoredType()		 * 		 * @see #isEdgesRestoredType()		 * 		 * @see #isNodesHiddenType()		 * 		 * @see #isEdgesHiddenType()		 * 		 */		public int getType()		{			return type;		}		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getRestoredNodes()} and		 * {@link #getRestoredNodeIndices()}		 * 		 * will return some Nodes and some FNode indices.		 * 		 * @return ( ( getType() & NODES_RESTORED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #NODES_RESTORED_TYPE		 * 		 */		public boolean isNodesRestoredType()		{			return ((type & NODES_RESTORED_TYPE) != 0);		} // isNodesRestoredType()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getRestoredEdges()} and		 * {@link #getRestoredEdgeIndices()}		 * 		 * will return some Edges and some FEdge indices.		 * 		 * @return ( ( getType() & EDGES_RESTORED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #EDGES_RESTORED_TYPE		 * 		 */		public boolean isEdgesRestoredType()		{			return ((type & EDGES_RESTORED_TYPE) != 0);		} // isEdgesRestoredType()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getHiddenNodes()} and		 * {@link #getHiddenNodeIndices()}		 * 		 * will return some Nodes and some FNode indices.		 * 		 * @return ( ( getType() & NODES_HIDDEN_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #NODES_HIDDEN_TYPE		 * 		 */		public boolean isNodesHiddenType()		{			return ((type & NODES_HIDDEN_TYPE) != 0);		} // isNodesHiddenType()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getHiddenEdges()} and		 * {@link #getHiddenEdgeIndices()}		 * 		 * will return some Edges and some FEdge indices.		 * 		 * @return ( ( getType() & EDGES_HIDDEN_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #EDGES_HIDDEN_TYPE		 * 		 */		public boolean isEdgesHiddenType()		{			return ((type & EDGES_HIDDEN_TYPE) != 0);		} // isEdgesHiddenType()		// ----------------------------------------		// Selection Stuff added by Rowan		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getSelectedNodes()} and		 * {@link #getSelectedNodeIndices()}		 * 		 * will return some Nodes and some FNode indices.		 * 		 * @return ( ( getType() & NODES_SELECTED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #NODES_SELECTED_TYPE		 * 		 */		public boolean isNodesSelectedType()		{			return ((type & NODES_SELECTED_TYPE) != 0);		} // isNodesSelectedType()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getUnselectedNodes()} and		 * {@link #getUnselectedNodeIndices()}		 * 		 * will return some Nodes and some FNode indices.		 * 		 * @return ( ( getType() & NODES_UNSELECTED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #NODES_UNSELECTED_TYPE		 * 		 */		public boolean isNodesUnselectedType()		{			return ((type & NODES_UNSELECTED_TYPE) != 0);		} // isNodesUnselected()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getSelectedEdges()} and		 * {@link #getSelectedEdgeIndices()}		 * 		 * will return some Edges and some FEdge indices.		 * 		 * @return ( ( getType() & EDGES_SELECTED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #EDGES_SELECTED_TYPE		 * 		 */		public boolean isEdgesSelectedType()		{			return ((type & EDGES_SELECTED_TYPE) != 0);		} // isEdgesSelectedType()		/**		 * 		 * A GraphPerspectiveChangeEvent can simultaneously represent multiple		 * 		 * simultaneous changes to its GraphPerspective source. This method		 * returns		 * 		 * true iff {@link #getUnselectedEdges()} and		 * {@link #getUnselectedEdgeIndices()}		 * 		 * will return some Edges and some FEdge indices.		 * 		 * @return ( ( getType() & EDGES_UNSELECTED_TYPE ) != 0 )		 * 		 * @see #getType()		 * 		 * @see #EDGES_UNSELECTED_TYPE		 * 		 */		public boolean isEdgesUnselectedType()		{			return ((type & EDGES_UNSELECTED_TYPE) != 0);		} // isEdgesUnselectedType()		// nodes		public FNode[] getSelectedNodes()		{			if ((type & NODES_SELECTED_TYPE) == 0)			{				return null;			}			if (selectedNodes == null)			{				selectedNodes = new FNode[selectedNodeIndices.length];				for (int node_i = 0; node_i < selectedNodes.length; node_i++)				{					selectedNodes[node_i] = ((PGraphView) source)							.getGraphPerspective().getNode(									selectedNodeIndices[node_i]);				}			}			return selectedNodes;		} // getSelectedNodes()		public int[] getSelectedNodeIndices()		{			if ((type & NODES_SELECTED_TYPE) == 0)			{				return null;			}			if (selectedNodeIndices == null)			{				selectedNodeIndices = new int[selectedNodes.length];				for (int node_i = 0; node_i < selectedNodeIndices.length; node_i++)				{					selectedNodeIndices[node_i] = getGraphPerspective()							.getRootGraph().getIndex(selectedNodes[node_i]);				}			}			return selectedNodeIndices;		} // getSelectedNodeIndices()		public FNode[] getUnselectedNodes()		{			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				return null;			}			if (unselectedNodes == null)			{				unselectedNodes = new FNode[unselectedNodeIndices.length];				for (int node_i = 0; node_i < unselectedNodes.length; node_i++)				{					unselectedNodes[node_i] = ((PGraphView) source)							.getGraphPerspective().getNode(									unselectedNodeIndices[node_i]);				}			}			return unselectedNodes;		} // getUnselectedNodes()		public int[] getUnselectedNodeIndices()		{			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				return null;			}			if (unselectedNodeIndices == null)			{				unselectedNodeIndices = new int[unselectedNodes.length];				for (int node_i = 0; node_i < unselectedNodeIndices.length; node_i++)				{					unselectedNodeIndices[node_i] = getGraphPerspective()							.getRootGraph().getIndex(unselectedNodes[node_i]);				}			}			return unselectedNodeIndices;		} // getUnselectedNodeIndices()		// Edges		public FEdge[] getSelectedEdges()		{			if ((type & EDGES_SELECTED_TYPE) == 0)			{				return null;			}			if (selectedEdges == null)			{				selectedEdges = new FEdge[selectedEdgeIndices.length];				for (int edge_i = 0; edge_i < selectedEdges.length; edge_i++)				{					selectedEdges[edge_i] = ((PGraphView) source)							.getGraphPerspective().getEdge(									selectedEdgeIndices[edge_i]);				}			}			return selectedEdges;		} // getSelectedEdges()		public int[] getSelectedEdgeIndices()		{			if ((type & EDGES_SELECTED_TYPE) == 0)			{				return null;			}			if (selectedEdgeIndices == null)			{				selectedEdgeIndices = new int[selectedEdges.length];				for (int edge_i = 0; edge_i < selectedEdgeIndices.length; edge_i++)				{					selectedEdgeIndices[edge_i] = getGraphPerspective()							.getRootGraph().getIndex(selectedEdges[edge_i]);				}			}			return selectedEdgeIndices;		} // getSelectedEdgeIndices()		public FEdge[] getUnselectedEdges()		{			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				return null;			}			if (unselectedEdges == null)			{				unselectedEdges = new FEdge[unselectedEdgeIndices.length];				for (int edge_i = 0; edge_i < unselectedEdges.length; edge_i++)				{					unselectedEdges[edge_i] = ((PGraphView) source)							.getGraphPerspective().getEdge(									unselectedEdgeIndices[edge_i]);				}			}			return unselectedEdges;		} // getUnselectedEdges()		public int[] getUnselectedEdgeIndices()		{			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				return null;			}			if (unselectedEdgeIndices == null)			{				unselectedEdgeIndices = new int[unselectedEdges.length];				for (int edge_i = 0; edge_i < unselectedEdgeIndices.length; edge_i++)				{					unselectedEdgeIndices[edge_i] = getGraphPerspective()							.getRootGraph().getIndex(unselectedEdges[edge_i]);				}			}			return unselectedEdgeIndices;		} // getUnselectedEdgeIndices()		// ----------------------------------------		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * NODES_RESTORED_TYPE, then this method will return the array of the		 * changed		 * 		 * Nodes. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that the use of {@link #getRestoredNodeIndices()} is recommended		 * over		 * 		 * use of this method. See {@link giny.model.GraphPerspective} for more		 * on		 * 		 * the efficiency of index accessors over object accessors.		 * 		 * <br>		 * 		 * Note that any FNode may appear multiple times in the returned array.		 * 		 * @return the array of newly restored Nodes, or null if there are none.		 * 		 * @see #getRestoredNodeIndices()		 * 		 * @see giny.model.GraphPerspective		 * 		 */		public FNode[] getRestoredNodes()		{			if ((type & NODES_RESTORED_TYPE) == 0)			{				return null;			}			if (restoredNodes == null)			{				restoredNodes = new FNode[restoredNodeIndices.length];				for (int node_i = 0; node_i < restoredNodes.length; node_i++)				{					restoredNodes[node_i] = ((PGraphView) source)							.getGraphPerspective().getNode(									restoredNodeIndices[node_i]);				}			}			return restoredNodes;		} // getRestoredNodes()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * EDGES_RESTORED_TYPE, then this method will return the array of the		 * changed		 * 		 * Edges. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that the use of {@link #getRestoredEdgeIndices()} is recommended		 * over		 * 		 * use of this method. See {@link giny.model.GraphPerspective} for more		 * on		 * 		 * the efficiency of index accessors over object accessors.		 * 		 * <br>		 * 		 * Note that any FEdge may appear multiple times in the returned array.		 * 		 * @return the array of newly restored Edges, or null if there are none.		 * 		 * @see #getRestoredEdgeIndices()		 * 		 * @see giny.model.GraphPerspective		 * 		 */		public FEdge[] getRestoredEdges()		{			if ((type & EDGES_RESTORED_TYPE) == 0)			{				return null;			}			if (restoredEdges == null)			{				restoredEdges = new FEdge[restoredEdgeIndices.length];				for (int edge_i = 0; edge_i < restoredEdges.length; edge_i++)				{					restoredEdges[edge_i] = ((PGraphView) source)							.getGraphPerspective().getEdge(									restoredEdgeIndices[edge_i]);				}			}			return restoredEdges;		} // getRestoredEdges()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * NODES_HIDDEN_TYPE, then this method will return the array of the		 * changed		 * 		 * Nodes. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that the use of {@link #getHiddenNodeIndices()} is recommended		 * over		 * 		 * use of this method. See {@link giny.model.GraphPerspective} for more		 * on		 * 		 * the efficiency of index accessors over object accessors.		 * 		 * <br>		 * 		 * Note that any FNode may appear multiple times in the returned array.		 * 		 * @return the array of newly hidden Nodes, or null if there are none.		 * 		 * @see #getHiddenNodeIndices()		 * 		 * @see giny.model.GraphPerspective		 * 		 */		public FNode[] getHiddenNodes()		{			if ((type & NODES_HIDDEN_TYPE) == 0)			{				return null;			}			if (hiddenNodes == null)			{				hiddenNodes = new FNode[hiddenNodeIndices.length];				for (int node_i = 0; node_i < hiddenNodes.length; node_i++)				{					hiddenNodes[node_i] = ((PGraphView) source)							.getGraphPerspective().getNode(									hiddenNodeIndices[node_i]);				}			}			return hiddenNodes;		} // getHiddenNodes()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * EDGES_HIDDEN_TYPE, then this method will return the array of the		 * changed		 * 		 * Edges. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that the use of {@link #getHiddenEdgeIndices()} is recommended		 * over		 * 		 * use of this method. See {@link giny.model.GraphPerspective} for more		 * on		 * 		 * the efficiency of index accessors over object accessors.		 * 		 * <br>		 * 		 * Note that any FEdge may appear multiple times in the returned array.		 * 		 * @return the array of newly hidden Edges, or null if there are none.		 * 		 * @see #getHiddenEdgeIndices()		 * 		 * @see giny.model.GraphPerspective		 * 		 */		public FEdge[] getHiddenEdges()		{			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				return null;			}			if (hiddenEdges == null)			{				hiddenEdges = new FEdge[hiddenEdgeIndices.length];				for (int edge_i = 0; edge_i < hiddenEdges.length; edge_i++)				{					hiddenEdges[edge_i] = ((PGraphView) source)							.getGraphPerspective().getEdge(									hiddenEdgeIndices[edge_i]);				}			}			return hiddenEdges;		} // getHiddenEdges()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * NODES_RESTORED_TYPE, then this method will return the array of the		 * changed		 * 		 * Nodes' RootGraph indices. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that any index may appear multiple times in the returned array.		 * 		 * @return the array of RootGraph indices of the newly restored Nodes,		 * or		 * 		 * null if there are none.		 * 		 */		public int[] getRestoredNodeIndices()		{			if ((type & NODES_RESTORED_TYPE) == 0)			{				return null;			}			if (restoredNodeIndices == null)			{				restoredNodeIndices = new int[restoredNodes.length];				for (int node_i = 0; node_i < restoredNodeIndices.length; node_i++)				{					restoredNodeIndices[node_i] = getGraphPerspective()							.getRootGraph().getIndex(restoredNodes[node_i]);				}			}			return restoredNodeIndices;		} // getRestoredNodeIndices()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * EDGES_RESTORED_TYPE, then this method will return the array of the		 * changed		 * 		 * Edges' RootGraph indices. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that any index may appear multiple times in the returned array.		 * 		 * @return the array of RootGraph indices of the newly restored Edges,		 * or		 * 		 * null if there are none.		 * 		 */		public int[] getRestoredEdgeIndices()		{			if ((type & EDGES_RESTORED_TYPE) == 0)			{				return null;			}			if (restoredEdgeIndices == null)			{				restoredEdgeIndices = new int[restoredEdges.length];				for (int edge_i = 0; edge_i < restoredEdgeIndices.length; edge_i++)				{					restoredEdgeIndices[edge_i] = getGraphPerspective()							.getRootGraph().getIndex(restoredEdges[edge_i]);				}			}			return restoredEdgeIndices;		} // getRestoredEdgeIndices()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * NODES_HIDDEN_TYPE, then this method will return the array of the		 * changed		 * 		 * Nodes' RootGraph indices. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that any index may appear multiple times in the returned array.		 * 		 * @return the array of RootGraph indices of the newly hidden Nodes, or		 * 		 * null if there are none.		 * 		 */		public int[] getHiddenNodeIndices()		{			if ((type & NODES_HIDDEN_TYPE) == 0)			{				return null;			}			if (hiddenNodeIndices == null)			{				hiddenNodeIndices = new int[hiddenNodes.length];				for (int node_i = 0; node_i < hiddenNodeIndices.length; node_i++)				{					hiddenNodeIndices[node_i] = getGraphPerspective()							.getRootGraph().getIndex(hiddenNodes[node_i]);				}			}			return hiddenNodeIndices;		} // getHiddenNodeIndices()		/**		 * 		 * If this GraphPerspectiveChangeEvent represents a change of type		 * 		 * EDGES_HIDDEN_TYPE, then this method will return the array of the		 * changed		 * 		 * Edges' RootGraph indices. Otherwise it will return null.		 * 		 * <br>		 * 		 * Note that the receiver should consider the returned array final; it		 * 		 * <b>must not</b> be modified. References to it may be kept, though		 * 		 * references to this GraphPerspectiveChangeEvent must not be kept.		 * 		 * <br>		 * 		 * Note that any index may appear multiple times in the returned array.		 * 		 * @return the array of RootGraph indices of the newly hidden Edges, or		 * 		 * null if there are none.		 * 		 */		public int[] getHiddenEdgeIndices()		{			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				return null;			}			if (hiddenEdgeIndices == null)			{				hiddenEdgeIndices = new int[hiddenEdges.length];				for (int edge_i = 0; edge_i < hiddenEdgeIndices.length; edge_i++)				{					hiddenEdgeIndices[edge_i] = getGraphPerspective()							.getRootGraph().getIndex(hiddenEdges[edge_i]);				}			}			return hiddenEdgeIndices;		} // getHiddenEdgeIndices()		/**		 * 		 * Add a node to the collection of newly hidden Nodes represented by		 * this		 * 		 * event. The event will be a NODES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given node will not have		 * already		 * 		 * been added to the collection of newly hidden Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param node The newly hidden FNode to add.		 * 		 */		public void addHiddenNode(FNode node)		{			if ((type & NODES_HIDDEN_TYPE) == 0)			{				hiddenNodes = new FNode[1];				hiddenNodes[0] = node;				type |= NODES_HIDDEN_TYPE;			} else			{				if (hiddenNodes != null)				{					FNode[] new_hidden_nodes = new FNode[hiddenNodes.length + 1];					System.arraycopy(hiddenNodes, 0, new_hidden_nodes, 0,							hiddenNodes.length);					new_hidden_nodes[hiddenNodes.length] = node;					hiddenNodes = new_hidden_nodes;				}				if (hiddenNodeIndices != null)				{					int[] new_hidden_node_indices = new int[hiddenNodeIndices.length + 1];					System.arraycopy(hiddenNodeIndices, 0,							new_hidden_node_indices, 0,							hiddenNodeIndices.length);					new_hidden_node_indices[hiddenNodeIndices.length] = node							.getRootGraphIndex();					hiddenNodeIndices = new_hidden_node_indices;				} // End if there's a hiddenNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// hidden nodes.		} // addHiddenNode( FNode )		/**		 * 		 * Add some nodes to the collection of newly hidden Nodes represented by		 * this		 * 		 * event. The event will be a NODES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly hidden Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_HIDDEN_TYPE.		 * 		 * @param nodes The array of newly hidden Nodes to add.		 * 		 */		public void addHiddenNodes(FNode[] nodes)		{			if ((type & NODES_HIDDEN_TYPE) == 0)			{				hiddenNodes = nodes;				type |= NODES_HIDDEN_TYPE;			} else			{				if (hiddenNodes != null)				{					FNode[] new_hidden_nodes = new FNode[hiddenNodes.length							+ nodes.length];					// Copy from the old hiddenNodes first.					System.arraycopy(hiddenNodes, 0, new_hidden_nodes, 0,							hiddenNodes.length);					// Now copy from the given nodes array.					System.arraycopy(nodes, 0, new_hidden_nodes,							hiddenNodes.length, nodes.length);					hiddenNodes = new_hidden_nodes;				}				if (hiddenNodeIndices != null)				{					int[] new_hidden_node_indices = new int[hiddenNodeIndices.length							+ nodes.length];					// Copy the old hiddenNodeIndices first.					System.arraycopy(hiddenNodeIndices, 0,							new_hidden_node_indices, 0,							hiddenNodeIndices.length);					// Now put in the new indices					for (int node_i = 0; node_i < nodes.length; node_i++)					{						new_hidden_node_indices[hiddenNodeIndices.length								+ node_i] = nodes[node_i].getRootGraphIndex();					}					hiddenNodeIndices = new_hidden_node_indices;				} // End if there's a hiddenNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// hidden nodes.		} // addHiddenNodes( FNode[] )		/**		 * 		 * Add a node to the collection of newly hidden Nodes represented by		 * this		 * 		 * event. The event will be a NODES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the node with the given index		 * will		 * 		 * not have already been added to the collection of newly hidden Nodes,		 * and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param node_index The index of the newly hidden FNode to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addHiddenNodeIndex(int node_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (node_index == 0)			{				throw new IllegalArgumentException(						"The node_index argument must not be 0.");			}			if (node_index > 0)			{				node_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphNodeIndex(node_index);			}			if ((type & NODES_HIDDEN_TYPE) == 0)			{				hiddenNodeIndices = new int[1];				hiddenNodeIndices[0] = node_index;				type |= NODES_HIDDEN_TYPE;			} else			{				if (hiddenNodeIndices != null)				{					int[] new_hidden_node_indices = new int[hiddenNodeIndices.length + 1];					System.arraycopy(hiddenNodeIndices, 0,							new_hidden_node_indices, 0,							hiddenNodeIndices.length);					new_hidden_node_indices[hiddenNodeIndices.length] = node_index;					hiddenNodeIndices = new_hidden_node_indices;				}				if (hiddenNodes != null)				{					FNode[] new_hidden_nodes = new FNode[hiddenNodes.length + 1];					System.arraycopy(hiddenNodes, 0, new_hidden_nodes, 0,							hiddenNodes.length);					new_hidden_nodes[hiddenNodes.length] = getGraphPerspective()							.getRootGraph().getNode(node_index);					hiddenNodes = new_hidden_nodes;				} // End if there's a hiddenNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// hidden nodes.		} // addHiddenNodeIndex( int )		/**		 * 		 * Add some nodes to the collection of newly hidden Nodes represented by		 * this		 * 		 * event. The event will be a NODES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly hidden Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_HIDDEN_TYPE.		 * 		 * @param node_indices The array of indices of newly hidden Nodes to add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addHiddenNodeIndices(int[] node_indices)		{			if ((type & NODES_HIDDEN_TYPE) == 0)			{				hiddenNodeIndices = node_indices;				type |= NODES_HIDDEN_TYPE;			} else			{				if (hiddenNodeIndices != null)				{					int[] new_hidden_node_indices = new int[hiddenNodeIndices.length							+ node_indices.length];					// Copy from the old hiddenNodeIndices first.					System.arraycopy(hiddenNodeIndices, 0,							new_hidden_node_indices, 0,							hiddenNodeIndices.length);					// Now copy from the given node indices array.					System.arraycopy(node_indices, 0, new_hidden_node_indices,							hiddenNodeIndices.length, node_indices.length);					hiddenNodeIndices = new_hidden_node_indices;				}				if (hiddenNodes != null)				{					FNode[] new_hidden_nodes = new FNode[hiddenNodes.length							+ node_indices.length];					// Copy the old hiddenNodes first.					System.arraycopy(hiddenNodes, 0, new_hidden_nodes, 0,							hiddenNodes.length);					// Now put in the new nodes					for (int node_index_i = 0; node_index_i < node_indices.length; node_index_i++)					{						new_hidden_nodes[hiddenNodes.length + node_index_i] = ((FGraphPerspective) source)								.getRootGraph().getNode(										node_indices[node_index_i]);					}					hiddenNodes = new_hidden_nodes;				} // End if there's a hiddenNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// hidden nodes.		} // addHiddenNodeIndices( int[] )		/**		 * 		 * Add a node to the collection of newly restored Nodes represented by		 * this		 * 		 * event. The event will be a NODES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given node will not have		 * already		 * 		 * been added to the collection of newly restored Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param node The newly restored FNode to add.		 * 		 */		public void addRestoredNode(FNode node)		{			if ((type & NODES_RESTORED_TYPE) == 0)			{				restoredNodes = new FNode[1];				restoredNodes[0] = node;				type |= NODES_RESTORED_TYPE;			} else			{				if (restoredNodes != null)				{					FNode[] new_restored_nodes = new FNode[restoredNodes.length + 1];					System.arraycopy(restoredNodes, 0, new_restored_nodes, 0,							restoredNodes.length);					new_restored_nodes[restoredNodes.length] = node;					restoredNodes = new_restored_nodes;				}				if (restoredNodeIndices != null)				{					int[] new_restored_node_indices = new int[restoredNodeIndices.length + 1];					System.arraycopy(restoredNodeIndices, 0,							new_restored_node_indices, 0,							restoredNodeIndices.length);					new_restored_node_indices[restoredNodeIndices.length] = node							.getRootGraphIndex();					restoredNodeIndices = new_restored_node_indices;				} // End if there's a restoredNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// restored nodes.		} // addRestoredNode( FNode )		/**		 * 		 * Add some nodes to the collection of newly restored Nodes represented		 * by this		 * 		 * event. The event will be a NODES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly restored Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_RESTORED_TYPE.		 * 		 * @param nodes The array of newly restored Nodes to add.		 * 		 */		public void addRestoredNodes(FNode[] nodes)		{			if ((type & NODES_RESTORED_TYPE) == 0)			{				restoredNodes = nodes;				type |= NODES_RESTORED_TYPE;			} else			{				if (restoredNodes != null)				{					FNode[] new_restored_nodes = new FNode[restoredNodes.length							+ nodes.length];					// Copy from the old restoredNodes first.					System.arraycopy(restoredNodes, 0, new_restored_nodes, 0,							restoredNodes.length);					// Now copy from the given nodes array.					System.arraycopy(nodes, 0, new_restored_nodes,							restoredNodes.length, nodes.length);					restoredNodes = new_restored_nodes;				}				if (restoredNodeIndices != null)				{					int[] new_restored_node_indices = new int[restoredNodeIndices.length							+ nodes.length];					// Copy the old restoredNodeIndices first.					System.arraycopy(restoredNodeIndices, 0,							new_restored_node_indices, 0,							restoredNodeIndices.length);					// Now put in the new indices					for (int node_i = 0; node_i < nodes.length; node_i++)					{						new_restored_node_indices[restoredNodeIndices.length								+ node_i] = nodes[node_i].getRootGraphIndex();					}					restoredNodeIndices = new_restored_node_indices;				} // End if there's a restoredNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// restored nodes.		} // addRestoredNodes( FNode[] )		/**		 * 		 * Add a node to the collection of newly restored Nodes represented by		 * this		 * 		 * event. The event will be a NODES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the node with the given index		 * will		 * 		 * not have already been added to the collection of newly restored		 * Nodes, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param node_index The index of the newly restored FNode to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addRestoredNodeIndex(int node_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (node_index == 0)			{				throw new IllegalArgumentException(						"The node_index argument must not be 0.");			}			if (node_index > 0)			{				node_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphNodeIndex(node_index);			}			if ((type & NODES_RESTORED_TYPE) == 0)			{				restoredNodeIndices = new int[1];				restoredNodeIndices[0] = node_index;				type |= NODES_RESTORED_TYPE;			} else			{				if (restoredNodeIndices != null)				{					int[] new_restored_node_indices = new int[restoredNodeIndices.length + 1];					System.arraycopy(restoredNodeIndices, 0,							new_restored_node_indices, 0,							restoredNodeIndices.length);					new_restored_node_indices[restoredNodeIndices.length] = node_index;					restoredNodeIndices = new_restored_node_indices;				}				if (restoredNodes != null)				{					FNode[] new_restored_nodes = new FNode[restoredNodes.length + 1];					System.arraycopy(restoredNodes, 0, new_restored_nodes, 0,							restoredNodes.length);					new_restored_nodes[restoredNodes.length] = getGraphPerspective()							.getRootGraph().getNode(node_index);					restoredNodes = new_restored_nodes;				} // End if there's a restoredNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// restored nodes.		} // addRestoredNodeIndex( int )		/**		 * 		 * Add some nodes to the collection of newly restored Nodes represented		 * by this		 * 		 * event. The event will be a NODES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly restored Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_RESTORED_TYPE.		 * 		 * @param node_indices The array of indices of newly restored Nodes to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addRestoredNodeIndices(int[] node_indices)		{			if ((type & NODES_RESTORED_TYPE) == 0)			{				restoredNodeIndices = node_indices;				type |= NODES_RESTORED_TYPE;			} else			{				if (restoredNodeIndices != null)				{					int[] new_restored_node_indices = new int[restoredNodeIndices.length							+ node_indices.length];					// Copy from the old restoredNodeIndices first.					System.arraycopy(restoredNodeIndices, 0,							new_restored_node_indices, 0,							restoredNodeIndices.length);					// Now copy from the given node indices array.					System.arraycopy(node_indices, 0,							new_restored_node_indices,							restoredNodeIndices.length, node_indices.length);					restoredNodeIndices = new_restored_node_indices;				}				if (restoredNodes != null)				{					FNode[] new_restored_nodes = new FNode[restoredNodes.length							+ node_indices.length];					// Copy the old restoredNodes first.					System.arraycopy(restoredNodes, 0, new_restored_nodes, 0,							restoredNodes.length);					// Now put in the new nodes					for (int node_index_i = 0; node_index_i < node_indices.length; node_index_i++)					{						new_restored_nodes[restoredNodes.length + node_index_i] = ((FGraphPerspective) source)								.getRootGraph().getNode(										node_indices[node_index_i]);					}					restoredNodes = new_restored_nodes;				} // End if there's a restoredNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// restored nodes.		} // addRestoredNodeIndices( int[] )		/**		 * 		 * Add a edge to the collection of newly hidden Edges represented by		 * this		 * 		 * event. The event will be a EDGES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given edge will not have		 * already		 * 		 * been added to the collection of newly hidden Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param edge The newly hidden FEdge to add.		 * 		 */		public void addHiddenEdge(FEdge edge)		{			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				hiddenEdges = new FEdge[1];				hiddenEdges[0] = edge;				type |= EDGES_HIDDEN_TYPE;			} else			{				if (hiddenEdges != null)				{					FEdge[] new_hidden_edges = new FEdge[hiddenEdges.length + 1];					System.arraycopy(hiddenEdges, 0, new_hidden_edges, 0,							hiddenEdges.length);					new_hidden_edges[hiddenEdges.length] = edge;					hiddenEdges = new_hidden_edges;				}				if (hiddenEdgeIndices != null)				{					int[] new_hidden_edge_indices = new int[hiddenEdgeIndices.length + 1];					System.arraycopy(hiddenEdgeIndices, 0,							new_hidden_edge_indices, 0,							hiddenEdgeIndices.length);					new_hidden_edge_indices[hiddenEdgeIndices.length] = edge							.getRootGraphIndex();					hiddenEdgeIndices = new_hidden_edge_indices;				} // End if there's a hiddenEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// hidden edges.		} // addHiddenEdge( FEdge )		/**		 * 		 * Add some edges to the collection of newly hidden Edges represented by		 * this		 * 		 * event. The event will be a EDGES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly hidden Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_HIDDEN_TYPE.		 * 		 * @param edges The array of newly hidden Edges to add.		 * 		 */		public void addHiddenEdges(FEdge[] edges)		{			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				hiddenEdges = edges;				type |= EDGES_HIDDEN_TYPE;			} else			{				if (hiddenEdges != null)				{					FEdge[] new_hidden_edges = new FEdge[hiddenEdges.length							+ edges.length];					// Copy from the old hiddenEdges first.					System.arraycopy(hiddenEdges, 0, new_hidden_edges, 0,							hiddenEdges.length);					// Now copy from the given edges array.					System.arraycopy(edges, 0, new_hidden_edges,							hiddenEdges.length, edges.length);					hiddenEdges = new_hidden_edges;				}				if (hiddenEdgeIndices != null)				{					int[] new_hidden_edge_indices = new int[hiddenEdgeIndices.length							+ edges.length];					// Copy the old hiddenEdgeIndices first.					System.arraycopy(hiddenEdgeIndices, 0,							new_hidden_edge_indices, 0,							hiddenEdgeIndices.length);					// Now put in the new indices					for (int edge_i = 0; edge_i < edges.length; edge_i++)					{						new_hidden_edge_indices[hiddenEdgeIndices.length								+ edge_i] = edges[edge_i].getRootGraphIndex();					}					hiddenEdgeIndices = new_hidden_edge_indices;				} // End if there's a hiddenEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// hidden edges.		} // addHiddenEdges( FEdge[] )		/**		 * 		 * Add a edge to the collection of newly hidden Edges represented by		 * this		 * 		 * event. The event will be a EDGES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the edge with the given index		 * will		 * 		 * not have already been added to the collection of newly hidden Edges,		 * and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param edge_index The index of the newly hidden FEdge to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addHiddenEdgeIndex(int edge_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (edge_index == 0)			{				throw new IllegalArgumentException(						"The edge_index argument must not be 0.");			}			if (edge_index > 0)			{				edge_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphEdgeIndex(edge_index);			}			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				hiddenEdgeIndices = new int[1];				hiddenEdgeIndices[0] = edge_index;				type |= EDGES_HIDDEN_TYPE;			} else			{				if (hiddenEdgeIndices != null)				{					int[] new_hidden_edge_indices = new int[hiddenEdgeIndices.length + 1];					System.arraycopy(hiddenEdgeIndices, 0,							new_hidden_edge_indices, 0,							hiddenEdgeIndices.length);					new_hidden_edge_indices[hiddenEdgeIndices.length] = edge_index;					hiddenEdgeIndices = new_hidden_edge_indices;				}				if (hiddenEdges != null)				{					FEdge[] new_hidden_edges = new FEdge[hiddenEdges.length + 1];					System.arraycopy(hiddenEdges, 0, new_hidden_edges, 0,							hiddenEdges.length);					new_hidden_edges[hiddenEdges.length] = getGraphPerspective()							.getRootGraph().getEdge(edge_index);					hiddenEdges = new_hidden_edges;				} // End if there's a hiddenEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// hidden edges.		} // addHiddenEdgeIndex( int )		/**		 * 		 * Add some edges to the collection of newly hidden Edges represented by		 * this		 * 		 * event. The event will be a EDGES_HIDDEN_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly hidden Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_HIDDEN_TYPE.		 * 		 * @param edge_indices The array of indices of newly hidden Edges to add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addHiddenEdgeIndices(int[] edge_indices)		{			if ((type & EDGES_HIDDEN_TYPE) == 0)			{				hiddenEdgeIndices = edge_indices;				type |= EDGES_HIDDEN_TYPE;			} else			{				if (hiddenEdgeIndices != null)				{					int[] new_hidden_edge_indices = new int[hiddenEdgeIndices.length							+ edge_indices.length];					// Copy from the old hiddenEdgeIndices first.					System.arraycopy(hiddenEdgeIndices, 0,							new_hidden_edge_indices, 0,							hiddenEdgeIndices.length);					// Now copy from the given edge indices array.					System.arraycopy(edge_indices, 0, new_hidden_edge_indices,							hiddenEdgeIndices.length, edge_indices.length);					hiddenEdgeIndices = new_hidden_edge_indices;				}				if (hiddenEdges != null)				{					FEdge[] new_hidden_edges = new FEdge[hiddenEdges.length							+ edge_indices.length];					// Copy the old hiddenEdges first.					System.arraycopy(hiddenEdges, 0, new_hidden_edges, 0,							hiddenEdges.length);					// Now put in the new edges					for (int edge_index_i = 0; edge_index_i < edge_indices.length; edge_index_i++)					{						new_hidden_edges[hiddenEdges.length + edge_index_i] = ((FGraphPerspective) source)								.getRootGraph().getEdge(										edge_indices[edge_index_i]);					}					hiddenEdges = new_hidden_edges;				} // End if there's a hiddenEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// hidden edges.		} // addHiddenEdgeIndices( int[] )		/**		 * 		 * Add a edge to the collection of newly restored Edges represented by		 * this		 * 		 * event. The event will be a EDGES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given edge will not have		 * already		 * 		 * been added to the collection of newly restored Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param edge The newly restored FEdge to add.		 * 		 */		public void addRestoredEdge(FEdge edge)		{			if ((type & EDGES_RESTORED_TYPE) == 0)			{				restoredEdges = new FEdge[1];				restoredEdges[0] = edge;				type |= EDGES_RESTORED_TYPE;			} else			{				if (restoredEdges != null)				{					FEdge[] new_restored_edges = new FEdge[restoredEdges.length + 1];					System.arraycopy(restoredEdges, 0, new_restored_edges, 0,							restoredEdges.length);					new_restored_edges[restoredEdges.length] = edge;					restoredEdges = new_restored_edges;				}				if (restoredEdgeIndices != null)				{					int[] new_restored_edge_indices = new int[restoredEdgeIndices.length + 1];					System.arraycopy(restoredEdgeIndices, 0,							new_restored_edge_indices, 0,							restoredEdgeIndices.length);					new_restored_edge_indices[restoredEdgeIndices.length] = edge							.getRootGraphIndex();					restoredEdgeIndices = new_restored_edge_indices;				} // End if there's a restoredEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// restored edges.		} // addRestoredEdge( FEdge )		/**		 * 		 * Add some edges to the collection of newly restored Edges represented		 * by this		 * 		 * event. The event will be a EDGES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly restored Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_RESTORED_TYPE.		 * 		 * @param edges The array of newly restored Edges to add.		 * 		 */		public void addRestoredEdges(FEdge[] edges)		{			if ((type & EDGES_RESTORED_TYPE) == 0)			{				restoredEdges = edges;				type |= EDGES_RESTORED_TYPE;			} else			{				if (restoredEdges != null)				{					FEdge[] new_restored_edges = new FEdge[restoredEdges.length							+ edges.length];					// Copy from the old restoredEdges first.					System.arraycopy(restoredEdges, 0, new_restored_edges, 0,							restoredEdges.length);					// Now copy from the given edges array.					System.arraycopy(edges, 0, new_restored_edges,							restoredEdges.length, edges.length);					restoredEdges = new_restored_edges;				}				if (restoredEdgeIndices != null)				{					int[] new_restored_edge_indices = new int[restoredEdgeIndices.length							+ edges.length];					// Copy the old restoredEdgeIndices first.					System.arraycopy(restoredEdgeIndices, 0,							new_restored_edge_indices, 0,							restoredEdgeIndices.length);					// Now put in the new indices					for (int edge_i = 0; edge_i < edges.length; edge_i++)					{						new_restored_edge_indices[restoredEdgeIndices.length								+ edge_i] = edges[edge_i].getRootGraphIndex();					}					restoredEdgeIndices = new_restored_edge_indices;				} // End if there's a restoredEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// restored edges.		} // addRestoredEdges( FEdge[] )		/**		 * 		 * Add a edge to the collection of newly restored Edges represented by		 * this		 * 		 * event. The event will be a EDGES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the edge with the given index		 * will		 * 		 * not have already been added to the collection of newly restored		 * Edges, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param edge_index The index of the newly restored FEdge to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addRestoredEdgeIndex(int edge_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (edge_index == 0)			{				throw new IllegalArgumentException(						"The edge_index argument must not be 0.");			}			if (edge_index > 0)			{				edge_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphEdgeIndex(edge_index);			}			if ((type & EDGES_RESTORED_TYPE) == 0)			{				restoredEdgeIndices = new int[1];				restoredEdgeIndices[0] = edge_index;				type |= EDGES_RESTORED_TYPE;			} else			{				if (restoredEdgeIndices != null)				{					int[] new_restored_edge_indices = new int[restoredEdgeIndices.length + 1];					System.arraycopy(restoredEdgeIndices, 0,							new_restored_edge_indices, 0,							restoredEdgeIndices.length);					new_restored_edge_indices[restoredEdgeIndices.length] = edge_index;					restoredEdgeIndices = new_restored_edge_indices;				}				if (restoredEdges != null)				{					FEdge[] new_restored_edges = new FEdge[restoredEdges.length + 1];					System.arraycopy(restoredEdges, 0, new_restored_edges, 0,							restoredEdges.length);					new_restored_edges[restoredEdges.length] = getGraphPerspective()							.getRootGraph().getEdge(edge_index);					restoredEdges = new_restored_edges;				} // End if there's a restoredEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// restored edges.		} // addRestoredEdgeIndex( int )		/**		 * 		 * Add some edges to the collection of newly restored Edges represented		 * by this		 * 		 * event. The event will be a EDGES_RESTORED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly restored Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_RESTORED_TYPE.		 * 		 * @param edge_indices The array of indices of newly restored Edges to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addRestoredEdgeIndices(int[] edge_indices)		{			if ((type & EDGES_RESTORED_TYPE) == 0)			{				restoredEdgeIndices = edge_indices;				type |= EDGES_RESTORED_TYPE;			} else			{				if (restoredEdgeIndices != null)				{					int[] new_restored_edge_indices = new int[restoredEdgeIndices.length							+ edge_indices.length];					// Copy from the old restoredEdgeIndices first.					System.arraycopy(restoredEdgeIndices, 0,							new_restored_edge_indices, 0,							restoredEdgeIndices.length);					// Now copy from the given edge indices array.					System.arraycopy(edge_indices, 0,							new_restored_edge_indices,							restoredEdgeIndices.length, edge_indices.length);					restoredEdgeIndices = new_restored_edge_indices;				}				if (restoredEdges != null)				{					FEdge[] new_restored_edges = new FEdge[restoredEdges.length							+ edge_indices.length];					// Copy the old restoredEdges first.					System.arraycopy(restoredEdges, 0, new_restored_edges, 0,							restoredEdges.length);					// Now put in the new edges					for (int edge_index_i = 0; edge_index_i < edge_indices.length; edge_index_i++)					{						new_restored_edges[restoredEdges.length + edge_index_i] = ((FGraphPerspective) source)								.getRootGraph().getEdge(										edge_indices[edge_index_i]);					}					restoredEdges = new_restored_edges;				} // End if there's a restoredEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// restored edges.		} // addRestoredEdgeIndices( int[] )		// ----------------------------------------		// Selection stuff		// Selected nodes		/**		 * 		 * Add a node to the collection of newly selected Nodes represented by		 * this		 * 		 * event. The event will be a NODES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given node will not have		 * already		 * 		 * been added to the collection of newly selected Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param node The newly selected FNode to add.		 * 		 */		public void addSelectedNode(FNode node)		{			if ((type & NODES_SELECTED_TYPE) == 0)			{				selectedNodes = new FNode[1];				selectedNodes[0] = node;				type |= NODES_SELECTED_TYPE;			} else			{				if (selectedNodes != null)				{					FNode[] new_selected_nodes = new FNode[selectedNodes.length + 1];					System.arraycopy(selectedNodes, 0, new_selected_nodes, 0,							selectedNodes.length);					new_selected_nodes[selectedNodes.length] = node;					selectedNodes = new_selected_nodes;				}				if (selectedNodeIndices != null)				{					int[] new_selected_node_indices = new int[selectedNodeIndices.length + 1];					System.arraycopy(selectedNodeIndices, 0,							new_selected_node_indices, 0,							selectedNodeIndices.length);					new_selected_node_indices[selectedNodeIndices.length] = node							.getRootGraphIndex();					selectedNodeIndices = new_selected_node_indices;				} // End if there's a selectedNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// selected nodes.		} // addSelectedNode( FNode )		/**		 * 		 * Add some nodes to the collection of newly selected Nodes represented		 * by this		 * 		 * event. The event will be a NODES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly selected Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_SELECTED_TYPE.		 * 		 * @param nodes The array of newly selected Nodes to add.		 * 		 */		public void addSelectedNodes(FNode[] nodes)		{			if ((type & NODES_SELECTED_TYPE) == 0)			{				selectedNodes = nodes;				type |= NODES_SELECTED_TYPE;			} else			{				if (selectedNodes != null)				{					FNode[] new_selected_nodes = new FNode[selectedNodes.length							+ nodes.length];					// Copy from the old selectedNodes first.					System.arraycopy(selectedNodes, 0, new_selected_nodes, 0,							selectedNodes.length);					// Now copy from the given nodes array.					System.arraycopy(nodes, 0, new_selected_nodes,							selectedNodes.length, nodes.length);					selectedNodes = new_selected_nodes;				}				if (selectedNodeIndices != null)				{					int[] new_selected_node_indices = new int[selectedNodeIndices.length							+ nodes.length];					// Copy the old selectedNodeIndices first.					System.arraycopy(selectedNodeIndices, 0,							new_selected_node_indices, 0,							selectedNodeIndices.length);					// Now put in the new indices					for (int node_i = 0; node_i < nodes.length; node_i++)					{						new_selected_node_indices[selectedNodeIndices.length								+ node_i] = nodes[node_i].getRootGraphIndex();					}					selectedNodeIndices = new_selected_node_indices;				} // End if there's a selectedNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// selected nodes.		} // addSelectedNodes( FNode[] )		/**		 * 		 * Add a node to the collection of newly selected Nodes represented by		 * this		 * 		 * event. The event will be a NODES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the node with the given index		 * will		 * 		 * not have already been added to the collection of newly selected		 * Nodes, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param node_index The index of the newly selected FNode to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addSelectedNodeIndex(int node_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (node_index == 0)			{				// throw new IllegalArgumentException( "The node_index argument				// must not be 0." );				System.out.println("The node_index argument must not be 0.");				return;			}			if (node_index > 0)			{				node_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphNodeIndex(node_index);			}			if ((type & NODES_SELECTED_TYPE) == 0)			{				selectedNodeIndices = new int[1];				selectedNodeIndices[0] = node_index;				type |= NODES_SELECTED_TYPE;			} else			{				if (selectedNodeIndices != null)				{					int[] new_selected_node_indices = new int[selectedNodeIndices.length + 1];					System.arraycopy(selectedNodeIndices, 0,							new_selected_node_indices, 0,							selectedNodeIndices.length);					new_selected_node_indices[selectedNodeIndices.length] = node_index;					selectedNodeIndices = new_selected_node_indices;				}				if (selectedNodes != null)				{					FNode[] new_selected_nodes = new FNode[selectedNodes.length + 1];					System.arraycopy(selectedNodes, 0, new_selected_nodes, 0,							selectedNodes.length);					new_selected_nodes[selectedNodes.length] = getGraphPerspective()							.getRootGraph().getNode(node_index);					selectedNodes = new_selected_nodes;				} // End if there's a selectedNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// selected nodes.		} // addSelectedNodeIndex( int )		/**		 * 		 * Add some nodes to the collection of newly selected Nodes represented		 * by this		 * 		 * event. The event will be a NODES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly selected Nodes, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_SELECTED_TYPE.		 * 		 * @param node_indices The array of indices of newly selected Nodes to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addSelectedNodeIndices(int[] node_indices)		{			if ((type & NODES_SELECTED_TYPE) == 0)			{				selectedNodeIndices = node_indices;				type |= NODES_SELECTED_TYPE;			} else			{				selectedNodeIndices = node_indices;			}		}// addSelectedNodeIndices( int[] )		// Unselected nodes		/**		 * 		 * Add a node to the collection of newly unselected Nodes represented by		 * this		 * 		 * event. The event will be a NODES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given node will not have		 * already		 * 		 * been added to the collection of newly unselected Nodes, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param node The newly unselected FNode to add.		 * 		 */		public void addUnselectedNode(FNode node)		{			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				unselectedNodes = new FNode[1];				unselectedNodes[0] = node;				type |= NODES_UNSELECTED_TYPE;			} else			{				if (unselectedNodes != null)				{					FNode[] new_unselected_nodes = new FNode[unselectedNodes.length + 1];					System.arraycopy(unselectedNodes, 0, new_unselected_nodes,							0, unselectedNodes.length);					new_unselected_nodes[unselectedNodes.length] = node;					unselectedNodes = new_unselected_nodes;				}				if (unselectedNodeIndices != null)				{					int[] new_unselected_node_indices = new int[unselectedNodeIndices.length + 1];					System.arraycopy(unselectedNodeIndices, 0,							new_unselected_node_indices, 0,							unselectedNodeIndices.length);					new_unselected_node_indices[unselectedNodeIndices.length] = node							.getRootGraphIndex();					unselectedNodeIndices = new_unselected_node_indices;				} // End if there's a unselectedNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// unselected nodes.		} // addUnselectedNode( FNode )		/**		 * 		 * Add some nodes to the collection of newly unselected Nodes		 * represented by this		 * 		 * event. The event will be a NODES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly unselected Nodes, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_UNSELECTED_TYPE.		 * 		 * @param nodes The array of newly unselected Nodes to add.		 * 		 */		public void addUnselectedNodes(FNode[] nodes)		{			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				unselectedNodes = nodes;				type |= NODES_UNSELECTED_TYPE;			} else			{				if (unselectedNodes != null)				{					FNode[] new_unselected_nodes = new FNode[unselectedNodes.length							+ nodes.length];					// Copy from the old unselectedNodes first.					System.arraycopy(unselectedNodes, 0, new_unselected_nodes,							0, unselectedNodes.length);					// Now copy from the given nodes array.					System.arraycopy(nodes, 0, new_unselected_nodes,							unselectedNodes.length, nodes.length);					unselectedNodes = new_unselected_nodes;				}				if (unselectedNodeIndices != null)				{					int[] new_unselected_node_indices = new int[unselectedNodeIndices.length							+ nodes.length];					// Copy the old unselectedNodeIndices first.					System.arraycopy(unselectedNodeIndices, 0,							new_unselected_node_indices, 0,							unselectedNodeIndices.length);					// Now put in the new indices					for (int node_i = 0; node_i < nodes.length; node_i++)					{						new_unselected_node_indices[unselectedNodeIndices.length								+ node_i] = nodes[node_i].getRootGraphIndex();					}					unselectedNodeIndices = new_unselected_node_indices;				} // End if there's a unselectedNodeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// unselected nodes.		} // addUnselectedNodes( FNode[] )		/**		 * 		 * Add a node to the collection of newly unselected Nodes represented by		 * this		 * 		 * event. The event will be a NODES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the node with the given index		 * will		 * 		 * not have already been added to the collection of newly unselected		 * Nodes, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param node_index The index of the newly unselected FNode to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addUnselectedNodeIndex(int node_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (node_index == 0)			{				throw new IllegalArgumentException(						"The node_index argument must not be 0.");			}			if (node_index > 0)			{				node_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphNodeIndex(node_index);			}			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				unselectedNodeIndices = new int[1];				unselectedNodeIndices[0] = node_index;				type |= NODES_UNSELECTED_TYPE;			} else			{				if (unselectedNodeIndices != null)				{					int[] new_unselected_node_indices = new int[unselectedNodeIndices.length + 1];					System.arraycopy(unselectedNodeIndices, 0,							new_unselected_node_indices, 0,							unselectedNodeIndices.length);					new_unselected_node_indices[unselectedNodeIndices.length] = node_index;					unselectedNodeIndices = new_unselected_node_indices;				}				if (unselectedNodes != null)				{					FNode[] new_unselected_nodes = new FNode[unselectedNodes.length + 1];					System.arraycopy(unselectedNodes, 0, new_unselected_nodes,							0, unselectedNodes.length);					new_unselected_nodes[unselectedNodes.length] = getGraphPerspective()							.getRootGraph().getNode(node_index);					unselectedNodes = new_unselected_nodes;				} // End if there's a unselectedNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// unselected nodes.		} // addUnselectedNodeIndex( int )		/**		 * 		 * Add some nodes to the collection of newly unselected Nodes		 * represented by this		 * 		 * event. The event will be a NODES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given node will not have		 * already		 * 		 * been added to the collection of newly unselected Nodes, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a NODES_UNSELECTED_TYPE.		 * 		 * @param node_indices The array of indices of newly unselected Nodes to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addUnselectedNodeIndices(int[] node_indices)		{			if ((type & NODES_UNSELECTED_TYPE) == 0)			{				unselectedNodeIndices = node_indices;				type |= NODES_UNSELECTED_TYPE;			} else			{				if (unselectedNodeIndices != null)				{					int[] new_unselected_node_indices = new int[unselectedNodeIndices.length							+ node_indices.length];					// Copy from the old unselectedNodeIndices first.					System.arraycopy(unselectedNodeIndices, 0,							new_unselected_node_indices, 0,							unselectedNodeIndices.length);					// Now copy from the given node indices array.					System.arraycopy(node_indices, 0,							new_unselected_node_indices,							unselectedNodeIndices.length, node_indices.length);					unselectedNodeIndices = new_unselected_node_indices;				}				if (unselectedNodes != null)				{					FNode[] new_unselected_nodes = new FNode[unselectedNodes.length							+ node_indices.length];					// Copy the old unselectedNodes first.					System.arraycopy(unselectedNodes, 0, new_unselected_nodes,							0, unselectedNodes.length);					// Now put in the new nodes					for (int node_index_i = 0; node_index_i < node_indices.length; node_index_i++)					{						new_unselected_nodes[unselectedNodes.length								+ node_index_i] = ((FGraphPerspective) source)								.getRootGraph().getNode(										node_indices[node_index_i]);					}					unselectedNodes = new_unselected_nodes;				} // End if there's a unselectedNodes array to maintain, too.			} // End if this is an extension to an existing collection of			// unselected nodes.		} // addUnselectedNodeIndices( int[] )		// edges		// Selected edges		/**		 * 		 * Add a edge to the collection of newly selected Edges represented by		 * this		 * 		 * event. The event will be a EDGES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given edge will not have		 * already		 * 		 * been added to the collection of newly selected Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param edge The newly selected FEdge to add.		 * 		 */		public void addSelectedEdge(FEdge edge)		{			if ((type & EDGES_SELECTED_TYPE) == 0)			{				selectedEdges = new FEdge[1];				selectedEdges[0] = edge;				type |= EDGES_SELECTED_TYPE;			} else			{				if (selectedEdges != null)				{					FEdge[] new_selected_edges = new FEdge[selectedEdges.length + 1];					System.arraycopy(selectedEdges, 0, new_selected_edges, 0,							selectedEdges.length);					new_selected_edges[selectedEdges.length] = edge;					selectedEdges = new_selected_edges;				}				if (selectedEdgeIndices != null)				{					int[] new_selected_edge_indices = new int[selectedEdgeIndices.length + 1];					System.arraycopy(selectedEdgeIndices, 0,							new_selected_edge_indices, 0,							selectedEdgeIndices.length);					new_selected_edge_indices[selectedEdgeIndices.length] = edge							.getRootGraphIndex();					selectedEdgeIndices = new_selected_edge_indices;				} // End if there's a selectedEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// selected edges.		} // addSelectedEdge( FEdge )		/**		 * 		 * Add some edges to the collection of newly selected Edges represented		 * by this		 * 		 * event. The event will be a EDGES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly selected Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_SELECTED_TYPE.		 * 		 * @param edges The array of newly selected Edges to add.		 * 		 */		public void addSelectedEdges(FEdge[] edges)		{			if ((type & EDGES_SELECTED_TYPE) == 0)			{				selectedEdges = edges;				type |= EDGES_SELECTED_TYPE;			} else			{				if (selectedEdges != null)				{					FEdge[] new_selected_edges = new FEdge[selectedEdges.length							+ edges.length];					// Copy from the old selectedEdges first.					System.arraycopy(selectedEdges, 0, new_selected_edges, 0,							selectedEdges.length);					// Now copy from the given edges array.					System.arraycopy(edges, 0, new_selected_edges,							selectedEdges.length, edges.length);					selectedEdges = new_selected_edges;				}				if (selectedEdgeIndices != null)				{					int[] new_selected_edge_indices = new int[selectedEdgeIndices.length							+ edges.length];					// Copy the old selectedEdgeIndices first.					System.arraycopy(selectedEdgeIndices, 0,							new_selected_edge_indices, 0,							selectedEdgeIndices.length);					// Now put in the new indices					for (int edge_i = 0; edge_i < edges.length; edge_i++)					{						new_selected_edge_indices[selectedEdgeIndices.length								+ edge_i] = edges[edge_i].getRootGraphIndex();					}					selectedEdgeIndices = new_selected_edge_indices;				} // End if there's a selectedEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// selected edges.		} // addSelectedEdges( FEdge[] )		/**		 * 		 * Add a edge to the collection of newly selected Edges represented by		 * this		 * 		 * event. The event will be a EDGES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the edge with the given index		 * will		 * 		 * not have already been added to the collection of newly selected		 * Edges, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param edge_index The index of the newly selected FEdge to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addSelectedEdgeIndex(int edge_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (edge_index == 0)			{				throw new IllegalArgumentException(						"The edge_index argument must not be 0.");			}			if (edge_index > 0)			{				edge_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphEdgeIndex(edge_index);			}			if ((type & EDGES_SELECTED_TYPE) == 0)			{				selectedEdgeIndices = new int[1];				selectedEdgeIndices[0] = edge_index;				type |= EDGES_SELECTED_TYPE;			} else			{				if (selectedEdgeIndices != null)				{					int[] new_selected_edge_indices = new int[selectedEdgeIndices.length + 1];					System.arraycopy(selectedEdgeIndices, 0,							new_selected_edge_indices, 0,							selectedEdgeIndices.length);					new_selected_edge_indices[selectedEdgeIndices.length] = edge_index;					selectedEdgeIndices = new_selected_edge_indices;				}				if (selectedEdges != null)				{					FEdge[] new_selected_edges = new FEdge[selectedEdges.length + 1];					System.arraycopy(selectedEdges, 0, new_selected_edges, 0,							selectedEdges.length);					new_selected_edges[selectedEdges.length] = getGraphPerspective()							.getRootGraph().getEdge(edge_index);					selectedEdges = new_selected_edges;				} // End if there's a selectedEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// selected edges.		} // addSelectedEdgeIndex( int )		/**		 * 		 * Add some edges to the collection of newly selected Edges represented		 * by this		 * 		 * event. The event will be a EDGES_SELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly selected Edges, and this method		 * does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_SELECTED_TYPE.		 * 		 * @param edge_indices The array of indices of newly selected Edges to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addSelectedEdgeIndices(int[] edge_indices)		{			if ((type & EDGES_SELECTED_TYPE) == 0)			{				selectedEdgeIndices = edge_indices;				type |= EDGES_SELECTED_TYPE;			} else			{				selectedEdgeIndices = edge_indices;			} // End if this is an extension to an existing collection of			// selected edges.		} // addSelectedEdgeIndices( int[] )		// Unselected Edges		// Unselected edges		/**		 * 		 * Add a edge to the collection of newly unselected Edges represented by		 * this		 * 		 * event. The event will be a EDGES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the given edge will not have		 * already		 * 		 * been added to the collection of newly unselected Edges, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * @param edge The newly unselected FEdge to add.		 * 		 */		public void addUnselectedEdge(FEdge edge)		{			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				unselectedEdges = new FEdge[1];				unselectedEdges[0] = edge;				type |= EDGES_UNSELECTED_TYPE;			} else			{				if (unselectedEdges != null)				{					FEdge[] new_unselected_edges = new FEdge[unselectedEdges.length + 1];					System.arraycopy(unselectedEdges, 0, new_unselected_edges,							0, unselectedEdges.length);					new_unselected_edges[unselectedEdges.length] = edge;					unselectedEdges = new_unselected_edges;				}				if (unselectedEdgeIndices != null)				{					int[] new_unselected_edge_indices = new int[unselectedEdgeIndices.length + 1];					System.arraycopy(unselectedEdgeIndices, 0,							new_unselected_edge_indices, 0,							unselectedEdgeIndices.length);					new_unselected_edge_indices[unselectedEdgeIndices.length] = edge							.getRootGraphIndex();					unselectedEdgeIndices = new_unselected_edge_indices;				} // End if there's a unselectedEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// unselected edges.		} // addUnselectedEdge( FEdge )		/**		 * 		 * Add some edges to the collection of newly unselected Edges		 * represented by this		 * 		 * event. The event will be a EDGES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly unselected Edges, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_UNSELECTED_TYPE.		 * 		 * @param edges The array of newly unselected Edges to add.		 * 		 */		public void addUnselectedEdges(FEdge[] edges)		{			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				unselectedEdges = edges;				type |= EDGES_UNSELECTED_TYPE;			} else			{				if (unselectedEdges != null)				{					FEdge[] new_unselected_edges = new FEdge[unselectedEdges.length							+ edges.length];					// Copy from the old unselectedEdges first.					System.arraycopy(unselectedEdges, 0, new_unselected_edges,							0, unselectedEdges.length);					// Now copy from the given edges array.					System.arraycopy(edges, 0, new_unselected_edges,							unselectedEdges.length, edges.length);					unselectedEdges = new_unselected_edges;				}				if (unselectedEdgeIndices != null)				{					int[] new_unselected_edge_indices = new int[unselectedEdgeIndices.length							+ edges.length];					// Copy the old unselectedEdgeIndices first.					System.arraycopy(unselectedEdgeIndices, 0,							new_unselected_edge_indices, 0,							unselectedEdgeIndices.length);					// Now put in the new indices					for (int edge_i = 0; edge_i < edges.length; edge_i++)					{						new_unselected_edge_indices[unselectedEdgeIndices.length								+ edge_i] = edges[edge_i].getRootGraphIndex();					}					unselectedEdgeIndices = new_unselected_edge_indices;				} // End if there's a unselectedEdgeIndices array to maintain,				// too.			} // End if this is an extension to an existing collection of			// unselected edges.		} // addUnselectedEdges( FEdge[] )		/**		 * 		 * Add a edge to the collection of newly unselected Edges represented by		 * this		 * 		 * event. The event will be a EDGES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that the edge with the given index		 * will		 * 		 * not have already been added to the collection of newly unselected		 * Edges, and		 * 		 * this method does not check. This is okay and should be handled when		 * retrieving the values.		 * 		 * @param edge_index The index of the newly unselected FEdge to add (the		 * index may		 * 		 * be either a RootGraph index or a GraphPerspective index when you add		 * it,		 * 		 * but it will always be returned as a RootGraph index).		 * 		 */		public void addUnselectedEdgeIndex(int edge_index)		{			// Make it a getGraphPerspective().getRootGraph() index if it isn't.			if (edge_index == 0)			{				throw new IllegalArgumentException(						"The edge_index argument must not be 0.");			}			if (edge_index > 0)			{				edge_index = ((PGraphView) source).getGraphPerspective()						.getRootGraphEdgeIndex(edge_index);			}			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				unselectedEdgeIndices = new int[1];				unselectedEdgeIndices[0] = edge_index;				type |= EDGES_UNSELECTED_TYPE;			} else			{				if (unselectedEdgeIndices != null)				{					int[] new_unselected_edge_indices = new int[unselectedEdgeIndices.length + 1];					System.arraycopy(unselectedEdgeIndices, 0,							new_unselected_edge_indices, 0,							unselectedEdgeIndices.length);					new_unselected_edge_indices[unselectedEdgeIndices.length] = edge_index;					unselectedEdgeIndices = new_unselected_edge_indices;				}				if (unselectedEdges != null)				{					FEdge[] new_unselected_edges = new FEdge[unselectedEdges.length + 1];					System.arraycopy(unselectedEdges, 0, new_unselected_edges,							0, unselectedEdges.length);					new_unselected_edges[unselectedEdges.length] = getGraphPerspective()							.getRootGraph().getEdge(edge_index);					unselectedEdges = new_unselected_edges;				} // End if there's a unselectedEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// unselected edges.		} // addUnselectedEdgeIndex( int )		/**		 * 		 * Add some edges to the collection of newly unselected Edges		 * represented by this		 * 		 * event. The event will be a EDGES_UNSELECTED_TYPE after calling this		 * method.		 * 		 * <br>		 * 		 * Note that there is no guarantee that any given edge will not have		 * already		 * 		 * been added to the collection of newly unselected Edges, and this		 * method does		 * 		 * not check. This is okay and should be handled when retrieving the		 * values.		 * 		 * <br>		 * 		 * Note that for efficiency this event will retain a reference to the		 * given		 * 		 * array if this event was not already a EDGES_UNSELECTED_TYPE.		 * 		 * @param edge_indices The array of indices of newly unselected Edges to		 * add		 * 		 * (each index may be either a RootGraph index or a GraphPerspective		 * 		 * index when you add it, but it will always be returned as a RootGraph		 * index).		 * 		 */		public void addUnselectedEdgeIndices(int[] edge_indices)		{			if ((type & EDGES_UNSELECTED_TYPE) == 0)			{				unselectedEdgeIndices = edge_indices;				type |= EDGES_UNSELECTED_TYPE;			} else			{				if (unselectedEdgeIndices != null)				{					int[] new_unselected_edge_indices = new int[unselectedEdgeIndices.length							+ edge_indices.length];					// Copy from the old unselectedEdgeIndices first.					System.arraycopy(unselectedEdgeIndices, 0,							new_unselected_edge_indices, 0,							unselectedEdgeIndices.length);					// Now copy from the given edge indices array.					System.arraycopy(edge_indices, 0,							new_unselected_edge_indices,							unselectedEdgeIndices.length, edge_indices.length);					unselectedEdgeIndices = new_unselected_edge_indices;				}				if (unselectedEdges != null)				{					FEdge[] new_unselected_edges = new FEdge[unselectedEdges.length							+ edge_indices.length];					// Copy the old unselectedEdges first.					System.arraycopy(unselectedEdges, 0, new_unselected_edges,							0, unselectedEdges.length);					// Now put in the new edges					for (int edge_index_i = 0; edge_index_i < edge_indices.length; edge_index_i++)					{						new_unselected_edges[unselectedEdges.length								+ edge_index_i] = ((FGraphPerspective) source)								.getRootGraph().getEdge(										edge_indices[edge_index_i]);					}					unselectedEdges = new_unselected_edges;				} // End if there's a unselectedEdges array to maintain, too.			} // End if this is an extension to an existing collection of			// unselected edges.		} // addUnselectedEdgeIndices( int[] )	}} // class PGraphView